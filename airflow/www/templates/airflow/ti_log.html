{#
Licensed to the Apache Software Foundation (ASF) under one or more
contributor license agreements.  See the NOTICE file distributed with
this work for additional information regarding copyright ownership.
The ASF licenses this file to You under the Apache License, Version 2.0
(the "License"); you may not use this file except in compliance with
the License.  You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

#}
{% extends "airflow/task_instance.html" %}
{% block title %}Airflow - DAGs{% endblock %}

{% block content %}
{{ super() }}
<h4>{{ title }}</h4>
<ul class="nav nav-pills" role="tablist">
  {% for log in logs %}
  <li role="presentation" class="{{ 'active' if loop.last else '' }}">
    <a href="#{{ loop.index }}" aria-controls="{{ loop.index }}" role="tab" data-toggle="tab">
      {{ loop.index }}
    </a>
  </li>
  {% endfor %}
</ul>
{% if tailing_logs_enabled %}
    <ul class="nav nav-pills pull-right">
      <li>
        <div class="dropdown">
          <button class="btn btn-primary dropdown-toggle" type="button" data-toggle="dropdown" id="tailLinesList">
            <span id="selected">Tail Logs</span><span class="caret"></span>
          </button>
          <ul class="dropdown-menu" aria-labelledby="tailLinesList" id="linesList">
            {% for tail_line in tail_lines_list %}
              <li class="dropdown-item"><a href="#" onClick="select_tail_lines(this)">{{ tail_line }}</a></li>
            {% endfor %}
            <li class="dropdown-item"><a href="#" onClick="select_tail_lines(this)">{{ full_log_title }}</a></li>
          </ul>
        </div>
      </li>
      <li>
        <button class="btn btn-default pull-right refresh_button" id="refresh-btn">
          <span class="glyphicon glyphicon-refresh" aria-hidden="true" title="Refresh Logs"></span>
        </button>
      </li>
    </ul>
{% endif %}
<div class="tab-content">
  {% for log in logs %}
  <div role="tabpanel" class="tab-pane {{ 'active' if loop.last else '' }}" id="{{ loop.index }}">
    <img id="loading-{{ loop.index }}" style="margin-top:0%; margin-left:50%; height:50px; width:50px; position: absolute;"
         alt="spinner" src="{{ url_for('static', filename='loading.gif') }}">
    <pre><code id="try-{{ loop.index }}">{{ log }}</code></pre>
  </div>
  {% endfor %}
  </div>
{% endblock %}
{% block tail %}
{{ super() }}
<script>
    // TODO: make those constants configurable.
    // Time interval to wait before next log fetching. Default 2s.
    const DELAY = 2e3;
    // Distance away from page bottom to enable auto tailing.
    const AUTO_TAILING_OFFSET = 30;
    // Animation speed for auto tailing log display.
    const ANIMATION_SPEED = 1000;
    // Total number of tabs to show.
    const TOTAL_ATTEMPTS = "{{ logs|length }}";
    // Text filter to render full log
    const FULL_LOG_TITLE = "{{ full_log_title }}";

    // Recursively fetch logs from flask endpoint.
    function recurse(delay=DELAY) {
      return new Promise((resolve) => setTimeout(resolve, delay));
    }

    // Enable auto tailing only when users scroll down to the bottom
    // of the page. This prevent auto tailing the page if users want
    // to view earlier rendered messages.
    function checkAutoTailingCondition() {
      const docHeight = $(document).height();
      console.debug($(window).scrollTop())
      console.debug($(window).height())
      console.debug($(document).height())
      return $(window).scrollTop() != 0
             && ($(window).scrollTop() + $(window).height() > docHeight - AUTO_TAILING_OFFSET);
    }

    // Streaming log with auto-tailing.
    function autoTailingLog(try_number, metadata=null, auto_tailing=false, append_log=true) {
      console.debug("Auto-tailing log for dag_id: {{ dag_id }}, task_id: {{ task_id }}, \
       execution_date: {{ execution_date }}, try_number: " + try_number + ", metadata: " + JSON.stringify(metadata));

      return Promise.resolve(
        $.ajax({
          url: "{{ url_for("Airflow.get_logs_with_metadata") }}",
          data: {
            dag_id: "{{ dag_id }}",
            task_id: "{{ task_id }}",
            execution_date: "{{ execution_date }}",
            try_number: try_number,
            metadata: JSON.stringify(metadata),
          },
        })).then(res => {
          // Stop recursive call to backend when error occurs.
          if (!res) {
            document.getElementById("loading-"+try_number).style.display = "none";
            return;
          }
          // res.error is a boolean
          // res.message is the log itself or the error message
          if (res.error) {
            if (res.message) {
              console.error("Error while retrieving log: " + res.message);
            }
            document.getElementById("loading-"+try_number).style.display = "none";
            return;
          }

          if (res.message) {
            // Auto scroll window to the end if current window location is near the end.
            if(auto_tailing && checkAutoTailingCondition()) {
              var should_scroll = true
            }
            // The message may contain HTML, so either have to escape it or write it as text.
            if(append_log){
              document.getElementById(`try-${try_number}`).textContent += res.message + "\n";
            }else{
              document.getElementById(`try-${try_number}`).textContent = res.message + "\n";
            }
            // Auto scroll window to the end if current window location is near the end.
            if(should_scroll) {
              $("html, body").animate({ scrollTop: $(document).height() }, ANIMATION_SPEED);
            }
          }

          if (res.metadata.end_of_log) {
            document.getElementById("loading-"+try_number).style.display = "none";
            return;
          }
          return recurse().then(() => autoTailingLog(
            try_number, res.metadata, auto_tailing));
        });
    }
    $(document).ready(function() {
      // Lazily load all past task instance logs.
      // TODO: We only need to have recursive queries for
      // latest running task instances. Currently it does not
      // work well with ElasticSearch because ES query only
      // returns at most 10k documents. We want the ability
      // to display all logs in the front-end.
      // An optimization here is to render from latest attempt.
      var metadata = {{ metadata|safe }};
      for(let i = TOTAL_ATTEMPTS; i >= 1; i--) {
        // Only auto_tailing the page when streaming the latest attempt.
        autoTailingLog(i, metadata, auto_tailing=(i == TOTAL_ATTEMPTS));
      }
      {% if tailing_logs_enabled %}
        var num_lines = parseInt(metadata.num_lines);
        if(!isNaN(num_lines)){
          $("span#selected").text(num_lines);
          $('span#selected').attr('data-original-title', `Tail last ${num_lines} lines`);
          $("ul#linesList").prepend(`<li class="dropdown-item"><a href="#" onClick="select_tail_lines(this)">${num_lines}</a></li><li class="divider"></li>`)
        }
        var text = $("span#selected").text()
        var tail_lines = parseInt(text);
        if(isNaN(tail_lines) && text != FULL_LOG_TITLE){
          $("#refresh-btn").attr("disabled", "disabled");
        }
      {% endif %}
    });

    {% if tailing_logs_enabled %}
      function select_tail_lines(obj){
        $('span#selected').text(obj.innerText);
        if(!isNaN(parseInt(obj.innerText))){
          $('span#selected').attr('data-original-title', `Tail last ${obj.innerText} lines`);
        }
        if(obj.innerText === FULL_LOG_TITLE){
          $('span#selected').attr('data-original-title', "Fetch full log");
        }
        if(isNaN(parseInt(obj.innerText)) && obj.innerText != FULL_LOG_TITLE){
          $("#refresh-btn").attr("disabled", "disabled");
        }else{
          $("#refresh-btn").prop("disabled", false);
        }
      }
      $("#refresh-btn").click(() => {
        var active_tab = $("li.active[role=presentation]").children()[0];
        if(active_tab){
          var active_tab_value = parseInt(active_tab.innerText);
          var text = $("span#selected").text();
          var tail_lines = parseInt(text);
          if(isNaN(tail_lines) && text != FULL_LOG_TITLE){
            alert(`${text} is not a valid integer`);
            return;
          }else if(isNaN(active_tab_value)){
            alert(`Invalid integer for active tab`);
            return;
          }
          var metadata = {{ metadata|safe }};
          metadata['num_lines'] = tail_lines;
          if(text === FULL_LOG_TITLE){
            metadata['tail_logs']=false;
          }
          autoTailingLog(active_tab_value, metadata, true, false);
        }else{
          alert(`Not Active Tabs found.`);
        }
      });
    {% endif %}

</script>
{% endblock %}
