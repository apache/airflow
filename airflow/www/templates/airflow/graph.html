{#
 Licensed to the Apache Software Foundation (ASF) under one
 or more contributor license agreements.  See the NOTICE file
 distributed with this work for additional information
 regarding copyright ownership.  The ASF licenses this file
 to you under the Apache License, Version 2.0 (the
 "License"); you may not use this file except in compliance
 with the License.  You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing,
 software distributed under the License is distributed on an
 "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 KIND, either express or implied.  See the License for the
 specific language governing permissions and limitations
 under the License.
#}

{% extends "airflow/dag.html" %}

{% block page_title %}{{ dag.dag_id }} - Graph - Airflow{% endblock %}

{% block head_css %}
{{ super() }}
<link rel="stylesheet" type="text/css" href="{{ url_for('static', filename='css/graph.css') }}">
<style type="text/css">
  {% for state, state_color in state_color_mapping.items() %}
    g.node.{{state}} rect {
      stroke: {{state_color}};
    }
  {% endfor %}
</style>
{% endblock %}

{% block content %}
{{ super() }}
{% if doc_md %}
{{ doc_md }}
{% endif %}
<div class="form-inline">
  <form method="get" style="float:left;">
    {{ state_token }}
    Base date: {{ form.base_date(class_="form-control") }}
    Number of runs: {{ form.num_runs(class_="form-control") }}
    Run:
    {{ form.execution_date(class_="form-control") }}
    Layout:
    {{ form.arrange(class_="form-control") }}
    <input type="hidden" name="root" value="{{ root }}">
    <input type="hidden" value="{{ dag.dag_id }}" name="dag_id">
    <input name="_csrf_token" type="hidden" value="{{ csrf_token() }}">
    <input type="submit" value="Go" class="btn btn-default">
  </form>
  <div class="input-group" style="float: right;">
    <input type="text" id="searchbox" class="form-control" placeholder="Search for...">
  </div>
  <div style="clear: both;"></div>
</div>
<hr/>
<div>
  {% for op in operators %}
  <div class="legend_item"
       style="border-width:1px;float:left;background:{{ op.ui_color }};color:{{ op.ui_fgcolor }};">
    {{ op.task_type }}
  </div>
  {% endfor %}

  <div>
    <div class="legend_item state" style="border-color:white;">no_status</div>
  {% for state, state_color in state_color_mapping.items() %}
    <div class="legend_item state" style="border-color:{{state_color}};">{{state}}</div>
  {% endfor %}
  </div>
  <div style="clear:both;"></div>
</div>
<div id="error" style="display: none; margin-top: 10px;" class="alert alert-danger" role="alert">
  <span class="glyphicon glyphicon-exclamation-sign" aria-hidden="true"></span>
  <span id="error_msg">Oops.</span>
</div>
<hr style="margin-bottom:0;"/>
<button class="btn btn-default pull-right" id="refresh_button">
  <span class="glyphicon glyphicon-refresh" aria-hidden="true"></span>
</button>
<div id="svg_container">

  <svg width="{{ width }}" height="{{ height }}">
    <g id='dig' transform="translate(20,20)"></g>
    <filter id="blur-effect-1">
      <feGaussianBlur stdDeviation="3"></feGaussianBlur>
    </filter>
  </svg>
  <img id="loading" alt="spinner" src="{{ url_for('static', filename='loading.gif') }}">
</div>
<hr>
{% endblock %}

{% block tail %}
{{ super() }}

<script src="{{ url_for_asset('d3.min.js') }}"></script>
<script src="{{ url_for_asset('dagre-d3.min.js') }}"></script>
<script src="{{ url_for_asset('d3-tip.js') }}"></script>

<script src="{{ url_for_asset('task-instances.js') }}"></script>
<script>

    var highlight_color = "#000000";
    var upstream_color = "#2020A0";
    var downstream_color = "#0000FF";
    var initialStrokeWidth = '3px';
    var highlightStrokeWidth = '5px';

    var nodes = {{ nodes|tojson }};
    var edges = {{ edges|tojson }};
    var execution_date = "{{ execution_date }}";
    var arrange = "{{ arrange }}";
    // This maps the actual task_id to the node_id that contains the task (because tasks may
    // be grouped into a group node)
    var map_task_to_node = new Map()

    // Below variables are being used in dag.js
    var tasks = {{ tasks|tojson }};
    var task_instances = {{ task_instances|tojson }};
    var getTaskInstanceURL = "{{ url_for('Airflow.task_instances') }}" +
      "?dag_id=" + encodeURIComponent(dag_id) + "&execution_date=" +
      encodeURIComponent(execution_date);

    var duration = 500;
    var stateFocusMap = {
        'success': false,
        'running':false,
        'failed':false,
        'skipped': false,
        'upstream_failed': false,
        'up_for_reschedule': false,
        'up_for_retry': false,
        'queued': false,
        'no_status': false
    };
    const taskTip = d3.tip()
      .attr('class', 'tooltip d3-tip')
      .html(function(toolTipHtml) {
        return toolTipHtml;
      });

    // Preparation of DagreD3 data structures
    var g = new dagreD3.graphlib.Graph({compound: true}).setGraph({
        nodesep: 15,
        ranksep: 15,
        rankdir: arrange,
      })
      .setDefaultEdgeLabel(function() { return { lineInterpolate: 'basis' } });

    var render = dagreD3.render(),
      svg = d3.select("svg"),
      innerSvg = d3.select("svg g");

      // Update the page to show the latest DAG.
      function draw() {
        innerSvg = svg.select("svg g");
        innerSvg.remove()
        innerSvg = svg.append("g")
        // Run the renderer. This is what draws the final graph.
        innerSvg.call(render, g);
        innerSvg.call(taskTip)

        // When an expanded group is clicked, collapse it.
        d3.selectAll("g.cluster").on("click", function (node_id) {
          node = g.node(node_id)
          collapse_group(node_id, node)
        })
        // When a node is clicked, action depends on the node type.
        d3.selectAll("g.node").on("click", function (node_id) {
          node = g.node(node_id)
          if (node.children != undefined && Object.keys(node.children).length > 0) {
            // A group node
            expand_group(node_id, node)
          } else {
            // A task node
            task = tasks[node_id];
            if (node_id in task_instances)
              try_number = task_instances[node_id].try_number;
            else
              try_number = 0;

            if (task.task_type == "SubDagOperator")
              call_modal(node_id, execution_date, task.extra_links, try_number, true);
            else
              call_modal(node_id, execution_date, task.extra_links, try_number, undefined);
          }
        });

        d3.selectAll("g.node").on("mouseover", function (d) {
          d3.select(this).selectAll("rect").style("stroke", highlight_color);
          highlight_nodes(g.predecessors(d), upstream_color, highlightStrokeWidth);
          highlight_nodes(g.successors(d), downstream_color, highlightStrokeWidth)
          adjacent_node_names = [d, ...g.predecessors(d), ...g.successors(d)]
          d3.selectAll("g.nodes g.node")
            .filter(x => !adjacent_node_names.includes(x))
            .style("opacity", 0.2);
          adjacent_edges = g.nodeEdges(d)
          d3.selectAll("g.edgePath")[0]
            .filter(x => !adjacent_edges.includes(x.__data__))
            .forEach(function (x) {
              d3.select(x).style('opacity', .2)
            })
        });

        d3.selectAll("g.node").on("mouseout", function (d) {
          d3.select(this).selectAll("rect").style("stroke", null);
          highlight_nodes(g.predecessors(d), null, initialStrokeWidth)
          highlight_nodes(g.successors(d), null, initialStrokeWidth)
          d3.selectAll("g.node")
            .style("opacity", 1);
          d3.selectAll("g.node rect")
            .style("stroke-width", initialStrokeWidth);
          d3.selectAll("g.edgePath")
            .style("opacity", 1);
        });
        updateNodesStates(task_instances);
        setUpZoomSupport(innerSvg);
      }

    function setUpZoomSupport(innerSvg) {
      // Set up zoom support for Graph
      var zoom = d3.behavior.zoom().on("zoom", function() {
            innerSvg.attr("transform", "translate(" + d3.event.translate + ")" +
                                        "scale(" + d3.event.scale + ")");
          });
      svg.call(zoom);

      // Centering the DAG on load
      // Get Dagre Graph dimensions
      var graphWidth = g.graph().width;
      var graphHeight = g.graph().height;
      // Get SVG dimensions
      var padding = 20;
      var svgBb = svg.node().getBoundingClientRect();
      var width = svgBb.width - padding*2;
      var height = svgBb.height - padding;  // we are not centering the dag vertically

      // Calculate applicable scale for zoom
      zoomScale = Math.min(
        Math.min(width / graphWidth, height / graphHeight),
        1.5,  // cap zoom level to 1.5 so nodes are not too large
      );

      zoom.translate([(width/2) - ((graphWidth*zoomScale)/2) + padding, padding]);
      zoom.scale(zoomScale);
      zoom.event(innerSvg);
    }

    function highlight_nodes(nodes, color, stroke_width) {
        nodes.forEach (function (nodeid) {
            my_node = d3.select('[id="' + nodeid + '"]').node().parentNode;
            d3.select(my_node)
                .selectAll("rect")
                .style("stroke", color)
                .style("stroke-width", stroke_width) ;
        })
    }


    {% if blur %}
    d3.selectAll("text").attr("class", "blur");
    {% endif %}

    d3.selectAll("div.legend_item.state")
        .style("cursor", "pointer")
        .on("mouseover", function(){
            if(!stateIsSet()){
                state = d3.select(this).text();
                focusState(state);
            }
        })
        .on("mouseout", function(){
            if(!stateIsSet()){
                clearFocus();
            }
        });

    d3.selectAll("div.legend_item.state")
        .on("click", function(){
            state = d3.select(this).text();
            color = d3.select(this).style("border-color");

            if (!stateFocusMap[state]){
                clearFocus();
                focusState(state, this, color);
                setFocusMap(state);

            } else {
                clearFocus();
                setFocusMap();
            }
        });

    d3.select("#searchbox").on("keyup", function(){
        var s = document.getElementById("searchbox").value;
        var match = null;

        if (stateIsSet){
            clearFocus();
            setFocusMap();
        }

        d3.selectAll("g.nodes g.node").filter(function(d, i){
            if (s==""){
                d3.select("g.edgePaths")
                    .transition().duration(duration)
                    .style("opacity", 1);
                d3.select(this)
                    .transition().duration(duration)
                    .style("opacity", 1)
                    .selectAll("rect")
                    .style("stroke-width", initialStrokeWidth);
            }
            else{
                d3.select("g.edgePaths")
                    .transition().duration(duration)
                    .style("opacity", 0.2);
                if (d.indexOf(s) > -1) {
                    if (!match)
                        match = this;
                    d3.select(this)
                        .transition().duration(duration)
                        .style("opacity", 1)
                        .selectAll("rect")
                        .style("stroke-width", highlightStrokeWidth);
                }
                else {
                    d3.select(this)
                        .transition()
                        .style("opacity", 0.2).duration(duration)
                        .selectAll("rect")
                        .style("stroke-width", initialStrokeWidth);
                }
            }
        });

        // This moves the matched node in the center of the graph area
        // ToDo: Should we keep this here as it has no added value
        // and does not fit the graph on small screens, and has to scroll
        if(match) {
            var transform = d3.transform(d3.select(match).attr("transform"));
            transform.translate = [
                -transform.translate[0] + 520,
                -(transform.translate[1] - 400)
            ];
            transform.scale = [1, 1];

            d3.select("g.zoom")
                .transition()
                .attr("transform", transform.toString());
            innerSvg.attr("transform", "translate(" + transform.translate + ")" +
                                        "scale(1)");
        }
    });

    function clearFocus(){
        d3.selectAll("g.node")
            .transition(duration)
            .style("opacity", 1);
        d3.selectAll("g.node rect")
            .transition(duration)
            .style("stroke-width", initialStrokeWidth);
        d3.select("g.edgePaths")
            .transition().duration(duration)
            .style("opacity", 1);
        d3.selectAll("div.legend_item.state")
            .style("background-color", null);
    }

    function focusState(state, node, color){
        d3.selectAll("g.node")
            .transition(duration)
            .style("opacity", 0.2);
        d3.selectAll("g.node."+state)
            .transition(duration)
            .style("opacity", 1);
        d3.selectAll("g.node." + state + " rect")
            .transition(duration)
            .style("stroke-width", highlightStrokeWidth)
            .style("opacity", 1);
        d3.select("g.edgePaths")
            .transition().duration(duration)
            .style("opacity", 0.2);
        d3.select(node)
            .style("background-color", color);
    }

    function setFocusMap(state){
        for (var key in stateFocusMap){
                stateFocusMap[key] = false;
        }
        if(state != null){
            stateFocusMap[state] = true;
        }
    }

    function stateIsSet(){
        for (var key in stateFocusMap){
            if (stateFocusMap[key]){
                return true
            }
        }
        return false
    }

    function initRefreshButton() {
      d3.select("#refresh_button").on("click", () => {
        $("#loading").css("display", "block");
        $("div#svg_container").css("opacity", "0.2");
        $.get(getTaskInstanceURL)
          .done(
            (tis) => {
              task_instances = JSON.parse(tis)
              updateNodesStates(task_instances);
              $("#loading").hide();
              $("div#svg_container").css("opacity", "1");
              $('#error').hide();
            }
          ).fail((_, textStatus, err) => {
            $('#error_msg').html(`${textStatus}: ${err}`);
            $('#error').show();
            $('#loading').hide();
            $('#chart_section').hide(1000);
            $('#datatable_section').hide(1000);
          });
      });
    }

    // Assigning css classes based on state to nodes
    // Initiating the tooltips
    function updateNodesStates(tis) {
      for(const node_id of g.nodes())
      {
        elem = g.node(node_id).elem;
        elem.setAttribute("class", "node enter " + get_node_state(node_id, tis));
        elem.setAttribute("data-toggle", "tooltip");

        const task_id = node_id;
        elem.onmouseover = (evt) => {
          if(task_id in tasks) {
            const task = tasks[task_id];
            const tt = tiTooltip(tis[task_id]);
            taskTip.show(tt, evt.target); // taskTip is defined in graph.html
          }
        };
        elem.onmouseout = taskTip.hide;
      }
    }


    // Returns list of children id of the given task group
    function get_children_ids(group) {
      var children = []
      for(const [key, val] of Object.entries(group.children)) {
        if(val.children == undefined) {
          // node
          children.push(val.id)
        } else {
          // group
          const sub_group_children = get_children_ids(val)
          for(const id of sub_group_children) {
            children.push(id)
          }
        }
      }
      return children
    }


    // Return the state for the node based on the state of its taskinstance or that of its
    // children if it's a group node
    function get_node_state(node_id, tis) {
      node = g.node(node_id)

      if (node.children == undefined) {
        if(node_id in tis)
          return tis[node_id].state

        return "no_status"
      }
      var children = get_children_ids(node)

      children_states = new Set()
      children.forEach(function(task_id) {
        if (task_id in tis) {
          var state = tis[task_id].state
          children_states.add(state == null ? "no_status" : state)
        }
      })

      // In this order, if any of these states appeared in children_states, return it as
      // the group state.
      var priority = ["failed", "upstream_failed", "up_for_retry","up_for_reschedule",
                      "queued", "no_status", "success", "skipped"]
      for(const state of priority) {
        if (children_states.has(state))
          return state
      }
      return "no_status"
    }

    // Expands a group node
    function expand_group(node_id, node) {
      node.children.forEach(function (val) {
        // Set children nodes
        g.setNode(val.id, val.value)
        map_task_to_node.set(val.id, val.id)
        g.node(val.id).id = val.id
        if (val.children != undefined) {
          // Set children attribute so that the group can be expanded later when needed.
          group_node = g.node(val.id)
          group_node.children = val.children
          // Map task that are under this node to this node's id
          for(const child_id of get_children_ids(val))
            map_task_to_node.set(child_id, val.id)
        }
        // Only call setParent if node is not the root node.
        if (node_id != null)
          g.setParent(val.id, node_id)
      })

      // Add edges
      edges.forEach(function(edge) {
        source_id = map_task_to_node.get(edge.source_id)
        target_id = map_task_to_node.get(edge.target_id)
        if(source_id != target_id)
          g.setEdge(source_id, target_id)
      })

      g.edges().forEach(function (edge) {
        // Remove edges that were associated with the expanded group node..
        if(node_id == edge.v || node_id == edge.w)
          g.removeEdge(edge.v, edge.w)
      })

      draw()
  }

  // Remove the node with this node_id from g.
  function remove_node(node_id) {
    if(g.hasNode(node_id)) {
        node = g.node(node_id)
        if(node.children != undefined) {
          // If the child is an expanded group node, remove children too.
          node.children.forEach(function (child) {
            remove_node(child.id)
          })
        }
    }
    g.removeNode(node_id)
  }

  // Collapse the children of the given group node.
  function collapse_group(node_id, node) {
      // Remove children nodes
      node.children.forEach(function(child) {
        remove_node(child.id)
      })
      // Map task that are under this node to this node's id
      for(const child_id of get_children_ids(node))
        map_task_to_node.set(child_id, node_id)

      node = g.node(node_id)

      // Set children edges onto the group edge
      edges.forEach(function(edge) {
        source_id = map_task_to_node.get(edge.source_id)
        target_id = map_task_to_node.get(edge.target_id)
        if(source_id != target_id)
          g.setEdge(source_id, target_id)
      })


      draw()
    }

    expand_group(null, nodes)

    updateNodesStates(task_instances);
    initRefreshButton();

</script>
<script src="{{ url_for_asset('graph.js') }}"></script>


{% endblock %}
