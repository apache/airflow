// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package api

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	JWTBearerScopes = "JWTBearer.Scopes"
)

// Defines values for DagRunState.
const (
	DagRunStateFailed  DagRunState = "failed"
	DagRunStateQueued  DagRunState = "queued"
	DagRunStateRunning DagRunState = "running"
	DagRunStateSuccess DagRunState = "success"
)

// Defines values for DagRunType.
const (
	AssetTriggered DagRunType = "asset_triggered"
	Backfill       DagRunType = "backfill"
	Manual         DagRunType = "manual"
	Scheduled      DagRunType = "scheduled"
)

// Defines values for IntermediateTIState.
const (
	IntermediateTIStateDeferred        IntermediateTIState = "deferred"
	IntermediateTIStateQueued          IntermediateTIState = "queued"
	IntermediateTIStateRestarting      IntermediateTIState = "restarting"
	IntermediateTIStateScheduled       IntermediateTIState = "scheduled"
	IntermediateTIStateUpForReschedule IntermediateTIState = "up_for_reschedule"
	IntermediateTIStateUpForRetry      IntermediateTIState = "up_for_retry"
	IntermediateTIStateUpstreamFailed  IntermediateTIState = "upstream_failed"
)

// Defines values for TIDeferredStatePayloadState.
const (
	Deferred TIDeferredStatePayloadState = "deferred"
)

// Defines values for TIEnterRunningPayloadState.
const (
	Running TIEnterRunningPayloadState = "running"
)

// Defines values for TIRescheduleStatePayloadState.
const (
	UpForReschedule TIRescheduleStatePayloadState = "up_for_reschedule"
)

// Defines values for TIRetryStatePayloadState.
const (
	UpForRetry TIRetryStatePayloadState = "up_for_retry"
)

// Defines values for TISuccessStatePayloadState.
const (
	TISuccessStatePayloadStateSuccess TISuccessStatePayloadState = "success"
)

// Defines values for TerminalStateNonSuccess.
const (
	Failed  TerminalStateNonSuccess = "failed"
	Removed TerminalStateNonSuccess = "removed"
	Skipped TerminalStateNonSuccess = "skipped"
)

// Defines values for TerminalTIState.
const (
	TerminalTIStateFailed  TerminalTIState = "failed"
	TerminalTIStateRemoved TerminalTIState = "removed"
	TerminalTIStateSkipped TerminalTIState = "skipped"
	TerminalTIStateSuccess TerminalTIState = "success"
)

// AssetAliasReferenceAssetEventDagRun Schema for AssetAliasModel used in AssetEventDagRunReference.
type AssetAliasReferenceAssetEventDagRun struct {
	Name string `json:"name"`
}

// AssetEventDagRunReference Schema for AssetEvent model used in DagRun.
type AssetEventDagRunReference struct {
	// Asset Schema for AssetModel used in AssetEventDagRunReference.
	Asset          AssetReferenceAssetEventDagRun        `json:"asset"`
	Extra          map[string]interface{}                `json:"extra"`
	SourceAliases  []AssetAliasReferenceAssetEventDagRun `json:"source_aliases"`
	SourceDagId    *string                               `json:"source_dag_id"`
	SourceMapIndex *int                                  `json:"source_map_index"`
	SourceRunId    *string                               `json:"source_run_id"`
	SourceTaskId   *string                               `json:"source_task_id"`
	Timestamp      time.Time                             `json:"timestamp"`
}

// AssetEventResponse Asset event schema with fields that are needed for Runtime.
type AssetEventResponse struct {
	// Asset Asset schema for responses with fields that are needed for Runtime.
	Asset          AssetResponse           `json:"asset"`
	CreatedDagruns []DagRunAssetReference  `json:"created_dagruns"`
	Extra          *map[string]interface{} `json:"extra"`
	Id             int                     `json:"id"`
	SourceDagId    *string                 `json:"source_dag_id"`
	SourceMapIndex *int                    `json:"source_map_index,omitempty"`
	SourceRunId    *string                 `json:"source_run_id"`
	SourceTaskId   *string                 `json:"source_task_id"`
	Timestamp      time.Time               `json:"timestamp"`
}

// AssetEventsResponse Collection of AssetEventResponse.
type AssetEventsResponse struct {
	AssetEvents []AssetEventResponse `json:"asset_events"`
}

// AssetProfile Profile of an asset-like object.
//
// Asset will have name, uri defined, with type set to 'Asset'.
// AssetNameRef will have name defined, type set to 'AssetNameRef'.
// AssetUriRef will have uri defined, type set to 'AssetUriRef'.
// AssetAlias will have name defined, type set to 'AssetAlias'.
//
// Note that 'type' here is distinct from 'asset_type' the user declares on an
// Asset (or subclass). This field is for distinguishing between different
// asset-related types (Asset, AssetRef, or AssetAlias).
type AssetProfile struct {
	Name *string `json:"name"`
	Type string  `json:"type"`
	Uri  *string `json:"uri"`
}

// AssetReferenceAssetEventDagRun Schema for AssetModel used in AssetEventDagRunReference.
type AssetReferenceAssetEventDagRun struct {
	Extra map[string]interface{} `json:"extra"`
	Name  string                 `json:"name"`
	Uri   string                 `json:"uri"`
}

// AssetResponse Asset schema for responses with fields that are needed for Runtime.
type AssetResponse struct {
	Extra *map[string]interface{} `json:"extra"`
	Group string                  `json:"group"`
	Name  string                  `json:"name"`
	Uri   string                  `json:"uri"`
}

// BundleInfo Schema for telling task which bundle to run with.
type BundleInfo struct {
	Name    string  `json:"name"`
	Version *string `json:"version"`
}

// ConnectionResponse Connection schema for responses with fields that are needed for Runtime.
type ConnectionResponse struct {
	ConnId   string  `json:"conn_id"`
	ConnType string  `json:"conn_type"`
	Extra    *string `json:"extra"`
	Host     *string `json:"host"`
	Login    *string `json:"login"`
	Password *string `json:"password"`
	Port     *int    `json:"port"`
	Schema   *string `json:"schema"`
}

// DagRun Schema for DagRun model with minimal required fields needed for Runtime.
type DagRun struct {
	ClearNumber         *int                        `json:"clear_number,omitempty"`
	Conf                *map[string]interface{}     `json:"conf,omitempty"`
	ConsumedAssetEvents []AssetEventDagRunReference `json:"consumed_asset_events"`
	DagId               string                      `json:"dag_id"`
	DataIntervalEnd     *time.Time                  `json:"data_interval_end"`
	DataIntervalStart   *time.Time                  `json:"data_interval_start"`
	EndDate             *time.Time                  `json:"end_date"`
	LogicalDate         *time.Time                  `json:"logical_date"`
	RunAfter            time.Time                   `json:"run_after"`
	RunId               string                      `json:"run_id"`

	// RunType Class with DagRun types.
	RunType   DagRunType `json:"run_type"`
	StartDate time.Time  `json:"start_date"`
}

// DagRunAssetReference DagRun serializer for asset responses.
type DagRunAssetReference struct {
	DagId             string     `json:"dag_id"`
	DataIntervalEnd   *time.Time `json:"data_interval_end"`
	DataIntervalStart *time.Time `json:"data_interval_start"`
	EndDate           *time.Time `json:"end_date"`
	LogicalDate       *time.Time `json:"logical_date"`
	RunId             string     `json:"run_id"`
	StartDate         time.Time  `json:"start_date"`
	State             string     `json:"state"`
}

// DagRunState All possible states that a DagRun can be in.
//
// These are "shared" with TaskInstanceState in some parts of the code,
// so please ensure that their values always match the ones with the
// same name in TaskInstanceState.
type DagRunState string

// DagRunStateResponse Schema for DAG Run State response.
type DagRunStateResponse struct {
	// State All possible states that a DagRun can be in.
	//
	// These are "shared" with TaskInstanceState in some parts of the code,
	// so please ensure that their values always match the ones with the
	// same name in TaskInstanceState.
	State DagRunState `json:"state"`
}

// DagRunType Class with DagRun types.
type DagRunType string

// HTTPValidationError defines model for HTTPValidationError.
type HTTPValidationError struct {
	Detail *[]ValidationError `json:"detail,omitempty"`
}

// IntermediateTIState States that a Task Instance can be in that indicate it is not yet in a terminal or running state.
type IntermediateTIState string

// JsonValue defines model for JsonValue.
type JsonValue struct {
	union json.RawMessage
}

// JsonValue0 defines model for .
type JsonValue0 = string

// JsonValue1 defines model for .
type JsonValue1 = float32

// JsonValue2 defines model for .
type JsonValue2 = int

// JsonValue3 defines model for .
type JsonValue3 = map[string]interface{}

// JsonValue4 defines model for .
type JsonValue4 = []interface{}

// JsonValue5 defines model for .
type JsonValue5 = bool

// PrevSuccessfulDagRunResponse Schema for response with previous successful DagRun information for Task Template Context.
type PrevSuccessfulDagRunResponse struct {
	DataIntervalEnd   *time.Time `json:"data_interval_end"`
	DataIntervalStart *time.Time `json:"data_interval_start"`
	EndDate           *time.Time `json:"end_date"`
	StartDate         *time.Time `json:"start_date"`
}

// TIDeferredStatePayload Schema for updating TaskInstance to a deferred state.
type TIDeferredStatePayload struct {
	Classpath      string                                `json:"classpath"`
	NextKwargs     *TIDeferredStatePayload_NextKwargs    `json:"next_kwargs,omitempty"`
	NextMethod     string                                `json:"next_method"`
	State          TIDeferredStatePayloadState           `json:"state"`
	TriggerKwargs  *TIDeferredStatePayload_TriggerKwargs `json:"trigger_kwargs,omitempty"`
	TriggerTimeout *string                               `json:"trigger_timeout"`
}

// TIDeferredStatePayloadNextKwargs0 defines model for .
type TIDeferredStatePayloadNextKwargs0 map[string]interface{}

// TIDeferredStatePayloadNextKwargs1 defines model for .
type TIDeferredStatePayloadNextKwargs1 = string

// TIDeferredStatePayload_NextKwargs defines model for TIDeferredStatePayload.NextKwargs.
type TIDeferredStatePayload_NextKwargs struct {
	union json.RawMessage
}

// TIDeferredStatePayloadState defines model for TIDeferredStatePayload.State.
type TIDeferredStatePayloadState string

// TIDeferredStatePayloadTriggerKwargs0 defines model for .
type TIDeferredStatePayloadTriggerKwargs0 map[string]interface{}

// TIDeferredStatePayloadTriggerKwargs1 defines model for .
type TIDeferredStatePayloadTriggerKwargs1 = string

// TIDeferredStatePayload_TriggerKwargs defines model for TIDeferredStatePayload.TriggerKwargs.
type TIDeferredStatePayload_TriggerKwargs struct {
	union json.RawMessage
}

// TIEnterRunningPayload Schema for updating TaskInstance to 'RUNNING' state with minimal required fields.
type TIEnterRunningPayload struct {
	Hostname  string                     `json:"hostname"`
	Pid       int                        `json:"pid"`
	StartDate time.Time                  `json:"start_date"`
	State     TIEnterRunningPayloadState `json:"state"`
	Unixname  string                     `json:"unixname"`
}

// TIEnterRunningPayloadState defines model for TIEnterRunningPayload.State.
type TIEnterRunningPayloadState string

// TIHeartbeatInfo Schema for TaskInstance heartbeat endpoint.
type TIHeartbeatInfo struct {
	Hostname string `json:"hostname"`
	Pid      int    `json:"pid"`
}

// TIRescheduleStatePayload Schema for updating TaskInstance to a up_for_reschedule state.
type TIRescheduleStatePayload struct {
	EndDate        time.Time                     `json:"end_date"`
	RescheduleDate time.Time                     `json:"reschedule_date"`
	State          TIRescheduleStatePayloadState `json:"state"`
}

// TIRescheduleStatePayloadState defines model for TIRescheduleStatePayload.State.
type TIRescheduleStatePayloadState string

// TIRetryStatePayload Schema for updating TaskInstance to up_for_retry.
type TIRetryStatePayload struct {
	EndDate time.Time                `json:"end_date"`
	State   TIRetryStatePayloadState `json:"state"`
}

// TIRetryStatePayloadState defines model for TIRetryStatePayload.State.
type TIRetryStatePayloadState string

// TIRunContext Response schema for TaskInstance run context.
type TIRunContext struct {
	Connections *[]ConnectionResponse `json:"connections,omitempty"`

	// DagRun Schema for DagRun model with minimal required fields needed for Runtime.
	DagRun              DagRun                   `json:"dag_run"`
	MaxTries            int                      `json:"max_tries"`
	NextKwargs          *TIRunContext_NextKwargs `json:"next_kwargs"`
	NextMethod          *string                  `json:"next_method"`
	ShouldRetry         bool                     `json:"should_retry"`
	TaskRescheduleCount *int                     `json:"task_reschedule_count,omitempty"`
	UpstreamMapIndexes  *map[string]int          `json:"upstream_map_indexes"`
	Variables           *[]VariableResponse      `json:"variables,omitempty"`
	XcomKeysToClear     *[]string                `json:"xcom_keys_to_clear,omitempty"`
}

// TIRunContextNextKwargs0 defines model for .
type TIRunContextNextKwargs0 map[string]interface{}

// TIRunContextNextKwargs1 defines model for .
type TIRunContextNextKwargs1 = string

// TIRunContext_NextKwargs defines model for TIRunContext.NextKwargs.
type TIRunContext_NextKwargs struct {
	union json.RawMessage
}

// TISkippedDownstreamTasksStatePayload Schema for updating downstream tasks to a skipped state.
type TISkippedDownstreamTasksStatePayload struct {
	Tasks []TISkippedDownstreamTasksStatePayload_Tasks_Item `json:"tasks"`
}

// TISkippedDownstreamTasksStatePayloadTasks0 defines model for .
type TISkippedDownstreamTasksStatePayloadTasks0 = string

// TISkippedDownstreamTasksStatePayloadTasks1 defines model for .
type TISkippedDownstreamTasksStatePayloadTasks1 = []interface{}

// TISkippedDownstreamTasksStatePayload_Tasks_Item defines model for TISkippedDownstreamTasksStatePayload.tasks.Item.
type TISkippedDownstreamTasksStatePayload_Tasks_Item struct {
	union json.RawMessage
}

// TISuccessStatePayload Schema for updating TaskInstance to success state.
type TISuccessStatePayload struct {
	EndDate      time.Time                  `json:"end_date"`
	OutletEvents *[]map[string]interface{}  `json:"outlet_events,omitempty"`
	State        TISuccessStatePayloadState `json:"state"`
	TaskOutlets  *[]AssetProfile            `json:"task_outlets,omitempty"`
}

// TISuccessStatePayloadState defines model for TISuccessStatePayload.State.
type TISuccessStatePayloadState string

// TITargetStatePayload Schema for updating TaskInstance to a target state, excluding terminal and running states.
type TITargetStatePayload struct {
	// State States that a Task Instance can be in that indicate it is not yet in a terminal or running state.
	State IntermediateTIState `json:"state"`
}

// TITerminalStatePayload Schema for updating TaskInstance to a terminal state except SUCCESS state.
type TITerminalStatePayload struct {
	EndDate time.Time `json:"end_date"`

	// State TaskInstance states that can be reported without extra information.
	State TerminalStateNonSuccess `json:"state"`
}

// TaskInstance Schema for TaskInstance model with minimal required fields needed for Runtime.
type TaskInstance struct {
	ContextCarrier *map[string]interface{} `json:"context_carrier"`
	DagId          string                  `json:"dag_id"`
	Hostname       *string                 `json:"hostname"`
	Id             openapi_types.UUID      `json:"id"`
	MapIndex       *int                    `json:"map_index,omitempty"`
	RunId          string                  `json:"run_id"`
	TaskId         string                  `json:"task_id"`
	TryNumber      int                     `json:"try_number"`
}

// TaskStatesResponse Response for task states with run_id, task and state.
type TaskStatesResponse struct {
	TaskStates map[string]interface{} `json:"task_states"`
}

// TerminalStateNonSuccess TaskInstance states that can be reported without extra information.
type TerminalStateNonSuccess string

// TerminalTIState defines model for TerminalTIState.
type TerminalTIState string

// TriggerDAGRunPayload Schema for Trigger DAG Run API request.
type TriggerDAGRunPayload struct {
	Conf        *map[string]interface{} `json:"conf,omitempty"`
	LogicalDate *time.Time              `json:"logical_date"`
	ResetDagRun *bool                   `json:"reset_dag_run,omitempty"`
}

// ValidationError defines model for ValidationError.
type ValidationError struct {
	Loc  []ValidationError_Loc_Item `json:"loc"`
	Msg  string                     `json:"msg"`
	Type string                     `json:"type"`
}

// ValidationErrorLoc0 defines model for .
type ValidationErrorLoc0 = string

// ValidationErrorLoc1 defines model for .
type ValidationErrorLoc1 = int

// ValidationError_Loc_Item defines model for ValidationError.loc.Item.
type ValidationError_Loc_Item struct {
	union json.RawMessage
}

// VariablePostBody Request body schema for creating variables.
type VariablePostBody struct {
	Description *string `json:"description"`
	Val         *string `json:"val"`
}

// VariableResponse Variable schema for responses with fields that are needed for Runtime.
type VariableResponse struct {
	Key   string  `json:"key"`
	Value *string `json:"value"`
}

// XComResponse XCom schema for responses with fields that are needed for Runtime.
type XComResponse struct {
	Key   string     `json:"key"`
	Value *JsonValue `json:"value"`
}

// GetAssetEventByAssetNameUriParams defines parameters for GetAssetEventByAssetNameUri.
type GetAssetEventByAssetNameUriParams struct {
	// Name The name of the Asset
	Name string `form:"name" json:"name"`

	// Uri The URI of the Asset
	Uri string `form:"uri" json:"uri"`
}

// GetAssetEventByAssetAliasParams defines parameters for GetAssetEventByAssetAlias.
type GetAssetEventByAssetAliasParams struct {
	// Name The name of the Asset Alias
	Name string `form:"name" json:"name"`
}

// GetAssetByNameParams defines parameters for GetAssetByName.
type GetAssetByNameParams struct {
	// Name The name of the Asset
	Name string `form:"name" json:"name"`
}

// GetAssetByUriParams defines parameters for GetAssetByUri.
type GetAssetByUriParams struct {
	// Uri The URI of the Asset
	Uri string `form:"uri" json:"uri"`
}

// GetDrCountParams defines parameters for GetDrCount.
type GetDrCountParams struct {
	DagId        string       `form:"dag_id" json:"dag_id"`
	LogicalDates *[]time.Time `form:"logical_dates,omitempty" json:"logical_dates,omitempty"`
	RunIds       *[]string    `form:"run_ids,omitempty" json:"run_ids,omitempty"`
	States       *[]string    `form:"states,omitempty" json:"states,omitempty"`
}

// GetTaskInstanceCountParams defines parameters for GetTaskInstanceCount.
type GetTaskInstanceCountParams struct {
	DagId        string       `form:"dag_id" json:"dag_id"`
	TaskIds      *[]string    `form:"task_ids,omitempty" json:"task_ids,omitempty"`
	TaskGroupId  *string      `form:"task_group_id,omitempty" json:"task_group_id,omitempty"`
	LogicalDates *[]time.Time `form:"logical_dates,omitempty" json:"logical_dates,omitempty"`
	RunIds       *[]string    `form:"run_ids,omitempty" json:"run_ids,omitempty"`
	States       *[]string    `form:"states,omitempty" json:"states,omitempty"`
}

// GetTaskInstanceStatesParams defines parameters for GetTaskInstanceStates.
type GetTaskInstanceStatesParams struct {
	DagId        string       `form:"dag_id" json:"dag_id"`
	TaskIds      *[]string    `form:"task_ids,omitempty" json:"task_ids,omitempty"`
	TaskGroupId  *string      `form:"task_group_id,omitempty" json:"task_group_id,omitempty"`
	LogicalDates *[]time.Time `form:"logical_dates,omitempty" json:"logical_dates,omitempty"`
	RunIds       *[]string    `form:"run_ids,omitempty" json:"run_ids,omitempty"`
}

// TiPutRtifJSONBody defines parameters for TiPutRtif.
type TiPutRtifJSONBody map[string]*JsonValue

// TiUpdateStateJSONBody defines parameters for TiUpdateState.
type TiUpdateStateJSONBody struct {
	union json.RawMessage
}

// DeleteXcomParams defines parameters for DeleteXcom.
type DeleteXcomParams struct {
	MapIndex *int `form:"map_index,omitempty" json:"map_index,omitempty"`
}

// GetXcomParams defines parameters for GetXcom.
type GetXcomParams struct {
	MapIndex          *int  `form:"map_index,omitempty" json:"map_index,omitempty"`
	IncludePriorDates *bool `form:"include_prior_dates,omitempty" json:"include_prior_dates,omitempty"`
}

// HeadXcomParams defines parameters for HeadXcom.
type HeadXcomParams struct {
	MapIndex *int `form:"map_index,omitempty" json:"map_index,omitempty"`
}

// SetXcomParams defines parameters for SetXcom.
type SetXcomParams struct {
	MapIndex *int `form:"map_index,omitempty" json:"map_index,omitempty"`

	// MappedLength Number of mapped tasks this value expands into
	MappedLength *int `form:"mapped_length,omitempty" json:"mapped_length,omitempty"`
}

// TriggerDagRunJSONRequestBody defines body for TriggerDagRun for application/json ContentType.
type TriggerDagRunJSONRequestBody = TriggerDAGRunPayload

// TiHeartbeatJSONRequestBody defines body for TiHeartbeat for application/json ContentType.
type TiHeartbeatJSONRequestBody = TIHeartbeatInfo

// TiPutRtifJSONRequestBody defines body for TiPutRtif for application/json ContentType.
type TiPutRtifJSONRequestBody TiPutRtifJSONBody

// TiRunJSONRequestBody defines body for TiRun for application/json ContentType.
type TiRunJSONRequestBody = TIEnterRunningPayload

// TiSkipDownstreamJSONRequestBody defines body for TiSkipDownstream for application/json ContentType.
type TiSkipDownstreamJSONRequestBody = TISkippedDownstreamTasksStatePayload

// TiUpdateStateJSONRequestBody defines body for TiUpdateState for application/json ContentType.
type TiUpdateStateJSONRequestBody TiUpdateStateJSONBody

// PutVariableJSONRequestBody defines body for PutVariable for application/json ContentType.
type PutVariableJSONRequestBody = VariablePostBody

// SetXcomJSONRequestBody defines body for SetXcom for application/json ContentType.
type SetXcomJSONRequestBody = JsonValue

// AsJsonValue0 returns the union data inside the JsonValue as a JsonValue0
func (t JsonValue) AsJsonValue0() (JsonValue0, error) {
	var body JsonValue0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromJsonValue0 overwrites any union data inside the JsonValue as the provided JsonValue0
func (t *JsonValue) FromJsonValue0(v JsonValue0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeJsonValue0 performs a merge with any union data inside the JsonValue, using the provided JsonValue0
func (t *JsonValue) MergeJsonValue0(v JsonValue0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsJsonValue1 returns the union data inside the JsonValue as a JsonValue1
func (t JsonValue) AsJsonValue1() (JsonValue1, error) {
	var body JsonValue1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromJsonValue1 overwrites any union data inside the JsonValue as the provided JsonValue1
func (t *JsonValue) FromJsonValue1(v JsonValue1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeJsonValue1 performs a merge with any union data inside the JsonValue, using the provided JsonValue1
func (t *JsonValue) MergeJsonValue1(v JsonValue1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsJsonValue2 returns the union data inside the JsonValue as a JsonValue2
func (t JsonValue) AsJsonValue2() (JsonValue2, error) {
	var body JsonValue2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromJsonValue2 overwrites any union data inside the JsonValue as the provided JsonValue2
func (t *JsonValue) FromJsonValue2(v JsonValue2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeJsonValue2 performs a merge with any union data inside the JsonValue, using the provided JsonValue2
func (t *JsonValue) MergeJsonValue2(v JsonValue2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsJsonValue3 returns the union data inside the JsonValue as a JsonValue3
func (t JsonValue) AsJsonValue3() (JsonValue3, error) {
	var body JsonValue3
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromJsonValue3 overwrites any union data inside the JsonValue as the provided JsonValue3
func (t *JsonValue) FromJsonValue3(v JsonValue3) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeJsonValue3 performs a merge with any union data inside the JsonValue, using the provided JsonValue3
func (t *JsonValue) MergeJsonValue3(v JsonValue3) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsJsonValue4 returns the union data inside the JsonValue as a JsonValue4
func (t JsonValue) AsJsonValue4() (JsonValue4, error) {
	var body JsonValue4
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromJsonValue4 overwrites any union data inside the JsonValue as the provided JsonValue4
func (t *JsonValue) FromJsonValue4(v JsonValue4) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeJsonValue4 performs a merge with any union data inside the JsonValue, using the provided JsonValue4
func (t *JsonValue) MergeJsonValue4(v JsonValue4) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsJsonValue5 returns the union data inside the JsonValue as a JsonValue5
func (t JsonValue) AsJsonValue5() (JsonValue5, error) {
	var body JsonValue5
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromJsonValue5 overwrites any union data inside the JsonValue as the provided JsonValue5
func (t *JsonValue) FromJsonValue5(v JsonValue5) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeJsonValue5 performs a merge with any union data inside the JsonValue, using the provided JsonValue5
func (t *JsonValue) MergeJsonValue5(v JsonValue5) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t JsonValue) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *JsonValue) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsTIDeferredStatePayloadNextKwargs0 returns the union data inside the TIDeferredStatePayload_NextKwargs as a TIDeferredStatePayloadNextKwargs0
func (t TIDeferredStatePayload_NextKwargs) AsTIDeferredStatePayloadNextKwargs0() (TIDeferredStatePayloadNextKwargs0, error) {
	var body TIDeferredStatePayloadNextKwargs0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTIDeferredStatePayloadNextKwargs0 overwrites any union data inside the TIDeferredStatePayload_NextKwargs as the provided TIDeferredStatePayloadNextKwargs0
func (t *TIDeferredStatePayload_NextKwargs) FromTIDeferredStatePayloadNextKwargs0(v TIDeferredStatePayloadNextKwargs0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTIDeferredStatePayloadNextKwargs0 performs a merge with any union data inside the TIDeferredStatePayload_NextKwargs, using the provided TIDeferredStatePayloadNextKwargs0
func (t *TIDeferredStatePayload_NextKwargs) MergeTIDeferredStatePayloadNextKwargs0(v TIDeferredStatePayloadNextKwargs0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTIDeferredStatePayloadNextKwargs1 returns the union data inside the TIDeferredStatePayload_NextKwargs as a TIDeferredStatePayloadNextKwargs1
func (t TIDeferredStatePayload_NextKwargs) AsTIDeferredStatePayloadNextKwargs1() (TIDeferredStatePayloadNextKwargs1, error) {
	var body TIDeferredStatePayloadNextKwargs1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTIDeferredStatePayloadNextKwargs1 overwrites any union data inside the TIDeferredStatePayload_NextKwargs as the provided TIDeferredStatePayloadNextKwargs1
func (t *TIDeferredStatePayload_NextKwargs) FromTIDeferredStatePayloadNextKwargs1(v TIDeferredStatePayloadNextKwargs1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTIDeferredStatePayloadNextKwargs1 performs a merge with any union data inside the TIDeferredStatePayload_NextKwargs, using the provided TIDeferredStatePayloadNextKwargs1
func (t *TIDeferredStatePayload_NextKwargs) MergeTIDeferredStatePayloadNextKwargs1(v TIDeferredStatePayloadNextKwargs1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t TIDeferredStatePayload_NextKwargs) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *TIDeferredStatePayload_NextKwargs) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsTIDeferredStatePayloadTriggerKwargs0 returns the union data inside the TIDeferredStatePayload_TriggerKwargs as a TIDeferredStatePayloadTriggerKwargs0
func (t TIDeferredStatePayload_TriggerKwargs) AsTIDeferredStatePayloadTriggerKwargs0() (TIDeferredStatePayloadTriggerKwargs0, error) {
	var body TIDeferredStatePayloadTriggerKwargs0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTIDeferredStatePayloadTriggerKwargs0 overwrites any union data inside the TIDeferredStatePayload_TriggerKwargs as the provided TIDeferredStatePayloadTriggerKwargs0
func (t *TIDeferredStatePayload_TriggerKwargs) FromTIDeferredStatePayloadTriggerKwargs0(v TIDeferredStatePayloadTriggerKwargs0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTIDeferredStatePayloadTriggerKwargs0 performs a merge with any union data inside the TIDeferredStatePayload_TriggerKwargs, using the provided TIDeferredStatePayloadTriggerKwargs0
func (t *TIDeferredStatePayload_TriggerKwargs) MergeTIDeferredStatePayloadTriggerKwargs0(v TIDeferredStatePayloadTriggerKwargs0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTIDeferredStatePayloadTriggerKwargs1 returns the union data inside the TIDeferredStatePayload_TriggerKwargs as a TIDeferredStatePayloadTriggerKwargs1
func (t TIDeferredStatePayload_TriggerKwargs) AsTIDeferredStatePayloadTriggerKwargs1() (TIDeferredStatePayloadTriggerKwargs1, error) {
	var body TIDeferredStatePayloadTriggerKwargs1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTIDeferredStatePayloadTriggerKwargs1 overwrites any union data inside the TIDeferredStatePayload_TriggerKwargs as the provided TIDeferredStatePayloadTriggerKwargs1
func (t *TIDeferredStatePayload_TriggerKwargs) FromTIDeferredStatePayloadTriggerKwargs1(v TIDeferredStatePayloadTriggerKwargs1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTIDeferredStatePayloadTriggerKwargs1 performs a merge with any union data inside the TIDeferredStatePayload_TriggerKwargs, using the provided TIDeferredStatePayloadTriggerKwargs1
func (t *TIDeferredStatePayload_TriggerKwargs) MergeTIDeferredStatePayloadTriggerKwargs1(v TIDeferredStatePayloadTriggerKwargs1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t TIDeferredStatePayload_TriggerKwargs) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *TIDeferredStatePayload_TriggerKwargs) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsTIRunContextNextKwargs0 returns the union data inside the TIRunContext_NextKwargs as a TIRunContextNextKwargs0
func (t TIRunContext_NextKwargs) AsTIRunContextNextKwargs0() (TIRunContextNextKwargs0, error) {
	var body TIRunContextNextKwargs0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTIRunContextNextKwargs0 overwrites any union data inside the TIRunContext_NextKwargs as the provided TIRunContextNextKwargs0
func (t *TIRunContext_NextKwargs) FromTIRunContextNextKwargs0(v TIRunContextNextKwargs0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTIRunContextNextKwargs0 performs a merge with any union data inside the TIRunContext_NextKwargs, using the provided TIRunContextNextKwargs0
func (t *TIRunContext_NextKwargs) MergeTIRunContextNextKwargs0(v TIRunContextNextKwargs0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTIRunContextNextKwargs1 returns the union data inside the TIRunContext_NextKwargs as a TIRunContextNextKwargs1
func (t TIRunContext_NextKwargs) AsTIRunContextNextKwargs1() (TIRunContextNextKwargs1, error) {
	var body TIRunContextNextKwargs1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTIRunContextNextKwargs1 overwrites any union data inside the TIRunContext_NextKwargs as the provided TIRunContextNextKwargs1
func (t *TIRunContext_NextKwargs) FromTIRunContextNextKwargs1(v TIRunContextNextKwargs1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTIRunContextNextKwargs1 performs a merge with any union data inside the TIRunContext_NextKwargs, using the provided TIRunContextNextKwargs1
func (t *TIRunContext_NextKwargs) MergeTIRunContextNextKwargs1(v TIRunContextNextKwargs1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t TIRunContext_NextKwargs) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *TIRunContext_NextKwargs) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsTISkippedDownstreamTasksStatePayloadTasks0 returns the union data inside the TISkippedDownstreamTasksStatePayload_Tasks_Item as a TISkippedDownstreamTasksStatePayloadTasks0
func (t TISkippedDownstreamTasksStatePayload_Tasks_Item) AsTISkippedDownstreamTasksStatePayloadTasks0() (TISkippedDownstreamTasksStatePayloadTasks0, error) {
	var body TISkippedDownstreamTasksStatePayloadTasks0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTISkippedDownstreamTasksStatePayloadTasks0 overwrites any union data inside the TISkippedDownstreamTasksStatePayload_Tasks_Item as the provided TISkippedDownstreamTasksStatePayloadTasks0
func (t *TISkippedDownstreamTasksStatePayload_Tasks_Item) FromTISkippedDownstreamTasksStatePayloadTasks0(v TISkippedDownstreamTasksStatePayloadTasks0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTISkippedDownstreamTasksStatePayloadTasks0 performs a merge with any union data inside the TISkippedDownstreamTasksStatePayload_Tasks_Item, using the provided TISkippedDownstreamTasksStatePayloadTasks0
func (t *TISkippedDownstreamTasksStatePayload_Tasks_Item) MergeTISkippedDownstreamTasksStatePayloadTasks0(v TISkippedDownstreamTasksStatePayloadTasks0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTISkippedDownstreamTasksStatePayloadTasks1 returns the union data inside the TISkippedDownstreamTasksStatePayload_Tasks_Item as a TISkippedDownstreamTasksStatePayloadTasks1
func (t TISkippedDownstreamTasksStatePayload_Tasks_Item) AsTISkippedDownstreamTasksStatePayloadTasks1() (TISkippedDownstreamTasksStatePayloadTasks1, error) {
	var body TISkippedDownstreamTasksStatePayloadTasks1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTISkippedDownstreamTasksStatePayloadTasks1 overwrites any union data inside the TISkippedDownstreamTasksStatePayload_Tasks_Item as the provided TISkippedDownstreamTasksStatePayloadTasks1
func (t *TISkippedDownstreamTasksStatePayload_Tasks_Item) FromTISkippedDownstreamTasksStatePayloadTasks1(v TISkippedDownstreamTasksStatePayloadTasks1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTISkippedDownstreamTasksStatePayloadTasks1 performs a merge with any union data inside the TISkippedDownstreamTasksStatePayload_Tasks_Item, using the provided TISkippedDownstreamTasksStatePayloadTasks1
func (t *TISkippedDownstreamTasksStatePayload_Tasks_Item) MergeTISkippedDownstreamTasksStatePayloadTasks1(v TISkippedDownstreamTasksStatePayloadTasks1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t TISkippedDownstreamTasksStatePayload_Tasks_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *TISkippedDownstreamTasksStatePayload_Tasks_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsValidationErrorLoc0 returns the union data inside the ValidationError_Loc_Item as a ValidationErrorLoc0
func (t ValidationError_Loc_Item) AsValidationErrorLoc0() (ValidationErrorLoc0, error) {
	var body ValidationErrorLoc0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromValidationErrorLoc0 overwrites any union data inside the ValidationError_Loc_Item as the provided ValidationErrorLoc0
func (t *ValidationError_Loc_Item) FromValidationErrorLoc0(v ValidationErrorLoc0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeValidationErrorLoc0 performs a merge with any union data inside the ValidationError_Loc_Item, using the provided ValidationErrorLoc0
func (t *ValidationError_Loc_Item) MergeValidationErrorLoc0(v ValidationErrorLoc0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsValidationErrorLoc1 returns the union data inside the ValidationError_Loc_Item as a ValidationErrorLoc1
func (t ValidationError_Loc_Item) AsValidationErrorLoc1() (ValidationErrorLoc1, error) {
	var body ValidationErrorLoc1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromValidationErrorLoc1 overwrites any union data inside the ValidationError_Loc_Item as the provided ValidationErrorLoc1
func (t *ValidationError_Loc_Item) FromValidationErrorLoc1(v ValidationErrorLoc1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeValidationErrorLoc1 performs a merge with any union data inside the ValidationError_Loc_Item, using the provided ValidationErrorLoc1
func (t *ValidationError_Loc_Item) MergeValidationErrorLoc1(v ValidationErrorLoc1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ValidationError_Loc_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ValidationError_Loc_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetAssetEventByAssetNameUri request
	GetAssetEventByAssetNameUri(ctx context.Context, params *GetAssetEventByAssetNameUriParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAssetEventByAssetAlias request
	GetAssetEventByAssetAlias(ctx context.Context, params *GetAssetEventByAssetAliasParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAssetByName request
	GetAssetByName(ctx context.Context, params *GetAssetByNameParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAssetByUri request
	GetAssetByUri(ctx context.Context, params *GetAssetByUriParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetConnection request
	GetConnection(ctx context.Context, connectionId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDrCount request
	GetDrCount(ctx context.Context, params *GetDrCountParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TriggerDagRunWithBody request with any body
	TriggerDagRunWithBody(ctx context.Context, dagId string, runId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TriggerDagRun(ctx context.Context, dagId string, runId string, body TriggerDagRunJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ClearDagRun request
	ClearDagRun(ctx context.Context, dagId string, runId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDagrunState request
	GetDagrunState(ctx context.Context, dagId string, runId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTaskInstanceCount request
	GetTaskInstanceCount(ctx context.Context, params *GetTaskInstanceCountParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTaskInstanceStates request
	GetTaskInstanceStates(ctx context.Context, params *GetTaskInstanceStatesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TiHeartbeatWithBody request with any body
	TiHeartbeatWithBody(ctx context.Context, taskInstanceId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TiHeartbeat(ctx context.Context, taskInstanceId openapi_types.UUID, body TiHeartbeatJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPreviousSuccessfulDagrun request
	GetPreviousSuccessfulDagrun(ctx context.Context, taskInstanceId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TiPutRtifWithBody request with any body
	TiPutRtifWithBody(ctx context.Context, taskInstanceId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TiPutRtif(ctx context.Context, taskInstanceId openapi_types.UUID, body TiPutRtifJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TiRunWithBody request with any body
	TiRunWithBody(ctx context.Context, taskInstanceId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TiRun(ctx context.Context, taskInstanceId openapi_types.UUID, body TiRunJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TiSkipDownstreamWithBody request with any body
	TiSkipDownstreamWithBody(ctx context.Context, taskInstanceId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TiSkipDownstream(ctx context.Context, taskInstanceId openapi_types.UUID, body TiSkipDownstreamJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TiUpdateStateWithBody request with any body
	TiUpdateStateWithBody(ctx context.Context, taskInstanceId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TiUpdateState(ctx context.Context, taskInstanceId openapi_types.UUID, body TiUpdateStateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStartDate request
	GetStartDate(ctx context.Context, taskInstanceId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteVariable request
	DeleteVariable(ctx context.Context, variableKey string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVariable request
	GetVariable(ctx context.Context, variableKey string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutVariableWithBody request with any body
	PutVariableWithBody(ctx context.Context, variableKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutVariable(ctx context.Context, variableKey string, body PutVariableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteXcom request
	DeleteXcom(ctx context.Context, dagId string, runId string, taskId string, key string, params *DeleteXcomParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetXcom request
	GetXcom(ctx context.Context, dagId string, runId string, taskId string, key string, params *GetXcomParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// HeadXcom request
	HeadXcom(ctx context.Context, dagId string, runId string, taskId string, key string, params *HeadXcomParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetXcomWithBody request with any body
	SetXcomWithBody(ctx context.Context, dagId string, runId string, taskId string, key string, params *SetXcomParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetXcom(ctx context.Context, dagId string, runId string, taskId string, key string, params *SetXcomParams, body SetXcomJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetAssetEventByAssetNameUri(ctx context.Context, params *GetAssetEventByAssetNameUriParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAssetEventByAssetNameUriRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAssetEventByAssetAlias(ctx context.Context, params *GetAssetEventByAssetAliasParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAssetEventByAssetAliasRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAssetByName(ctx context.Context, params *GetAssetByNameParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAssetByNameRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAssetByUri(ctx context.Context, params *GetAssetByUriParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAssetByUriRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetConnection(ctx context.Context, connectionId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConnectionRequest(c.Server, connectionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDrCount(ctx context.Context, params *GetDrCountParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDrCountRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TriggerDagRunWithBody(ctx context.Context, dagId string, runId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTriggerDagRunRequestWithBody(c.Server, dagId, runId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TriggerDagRun(ctx context.Context, dagId string, runId string, body TriggerDagRunJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTriggerDagRunRequest(c.Server, dagId, runId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ClearDagRun(ctx context.Context, dagId string, runId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewClearDagRunRequest(c.Server, dagId, runId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDagrunState(ctx context.Context, dagId string, runId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDagrunStateRequest(c.Server, dagId, runId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTaskInstanceCount(ctx context.Context, params *GetTaskInstanceCountParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTaskInstanceCountRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTaskInstanceStates(ctx context.Context, params *GetTaskInstanceStatesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTaskInstanceStatesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TiHeartbeatWithBody(ctx context.Context, taskInstanceId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTiHeartbeatRequestWithBody(c.Server, taskInstanceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TiHeartbeat(ctx context.Context, taskInstanceId openapi_types.UUID, body TiHeartbeatJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTiHeartbeatRequest(c.Server, taskInstanceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPreviousSuccessfulDagrun(ctx context.Context, taskInstanceId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPreviousSuccessfulDagrunRequest(c.Server, taskInstanceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TiPutRtifWithBody(ctx context.Context, taskInstanceId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTiPutRtifRequestWithBody(c.Server, taskInstanceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TiPutRtif(ctx context.Context, taskInstanceId openapi_types.UUID, body TiPutRtifJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTiPutRtifRequest(c.Server, taskInstanceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TiRunWithBody(ctx context.Context, taskInstanceId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTiRunRequestWithBody(c.Server, taskInstanceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TiRun(ctx context.Context, taskInstanceId openapi_types.UUID, body TiRunJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTiRunRequest(c.Server, taskInstanceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TiSkipDownstreamWithBody(ctx context.Context, taskInstanceId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTiSkipDownstreamRequestWithBody(c.Server, taskInstanceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TiSkipDownstream(ctx context.Context, taskInstanceId openapi_types.UUID, body TiSkipDownstreamJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTiSkipDownstreamRequest(c.Server, taskInstanceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TiUpdateStateWithBody(ctx context.Context, taskInstanceId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTiUpdateStateRequestWithBody(c.Server, taskInstanceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TiUpdateState(ctx context.Context, taskInstanceId openapi_types.UUID, body TiUpdateStateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTiUpdateStateRequest(c.Server, taskInstanceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStartDate(ctx context.Context, taskInstanceId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStartDateRequest(c.Server, taskInstanceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteVariable(ctx context.Context, variableKey string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteVariableRequest(c.Server, variableKey)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVariable(ctx context.Context, variableKey string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVariableRequest(c.Server, variableKey)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutVariableWithBody(ctx context.Context, variableKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutVariableRequestWithBody(c.Server, variableKey, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutVariable(ctx context.Context, variableKey string, body PutVariableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutVariableRequest(c.Server, variableKey, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteXcom(ctx context.Context, dagId string, runId string, taskId string, key string, params *DeleteXcomParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteXcomRequest(c.Server, dagId, runId, taskId, key, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetXcom(ctx context.Context, dagId string, runId string, taskId string, key string, params *GetXcomParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetXcomRequest(c.Server, dagId, runId, taskId, key, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HeadXcom(ctx context.Context, dagId string, runId string, taskId string, key string, params *HeadXcomParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHeadXcomRequest(c.Server, dagId, runId, taskId, key, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetXcomWithBody(ctx context.Context, dagId string, runId string, taskId string, key string, params *SetXcomParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetXcomRequestWithBody(c.Server, dagId, runId, taskId, key, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetXcom(ctx context.Context, dagId string, runId string, taskId string, key string, params *SetXcomParams, body SetXcomJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetXcomRequest(c.Server, dagId, runId, taskId, key, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetAssetEventByAssetNameUriRequest generates requests for GetAssetEventByAssetNameUri
func NewGetAssetEventByAssetNameUriRequest(server string, params *GetAssetEventByAssetNameUriParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/asset-events/by-asset")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, params.Name); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "uri", runtime.ParamLocationQuery, params.Uri); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAssetEventByAssetAliasRequest generates requests for GetAssetEventByAssetAlias
func NewGetAssetEventByAssetAliasRequest(server string, params *GetAssetEventByAssetAliasParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/asset-events/by-asset-alias")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, params.Name); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAssetByNameRequest generates requests for GetAssetByName
func NewGetAssetByNameRequest(server string, params *GetAssetByNameParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/assets/by-name")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, params.Name); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAssetByUriRequest generates requests for GetAssetByUri
func NewGetAssetByUriRequest(server string, params *GetAssetByUriParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/assets/by-uri")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "uri", runtime.ParamLocationQuery, params.Uri); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetConnectionRequest generates requests for GetConnection
func NewGetConnectionRequest(server string, connectionId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "connection_id", runtime.ParamLocationPath, connectionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/connections/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDrCountRequest generates requests for GetDrCount
func NewGetDrCountRequest(server string, params *GetDrCountParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dag-runs/count")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dag_id", runtime.ParamLocationQuery, params.DagId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.LogicalDates != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "logical_dates", runtime.ParamLocationQuery, *params.LogicalDates); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RunIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "run_ids", runtime.ParamLocationQuery, *params.RunIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.States != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "states", runtime.ParamLocationQuery, *params.States); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTriggerDagRunRequest calls the generic TriggerDagRun builder with application/json body
func NewTriggerDagRunRequest(server string, dagId string, runId string, body TriggerDagRunJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTriggerDagRunRequestWithBody(server, dagId, runId, "application/json", bodyReader)
}

// NewTriggerDagRunRequestWithBody generates requests for TriggerDagRun with any type of body
func NewTriggerDagRunRequestWithBody(server string, dagId string, runId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "dag_id", runtime.ParamLocationPath, dagId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "run_id", runtime.ParamLocationPath, runId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dag-runs/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewClearDagRunRequest generates requests for ClearDagRun
func NewClearDagRunRequest(server string, dagId string, runId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "dag_id", runtime.ParamLocationPath, dagId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "run_id", runtime.ParamLocationPath, runId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dag-runs/%s/%s/clear", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDagrunStateRequest generates requests for GetDagrunState
func NewGetDagrunStateRequest(server string, dagId string, runId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "dag_id", runtime.ParamLocationPath, dagId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "run_id", runtime.ParamLocationPath, runId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dag-runs/%s/%s/state", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTaskInstanceCountRequest generates requests for GetTaskInstanceCount
func NewGetTaskInstanceCountRequest(server string, params *GetTaskInstanceCountParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/task-instances/count")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dag_id", runtime.ParamLocationQuery, params.DagId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TaskIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "task_ids", runtime.ParamLocationQuery, *params.TaskIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TaskGroupId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "task_group_id", runtime.ParamLocationQuery, *params.TaskGroupId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LogicalDates != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "logical_dates", runtime.ParamLocationQuery, *params.LogicalDates); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RunIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "run_ids", runtime.ParamLocationQuery, *params.RunIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.States != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "states", runtime.ParamLocationQuery, *params.States); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTaskInstanceStatesRequest generates requests for GetTaskInstanceStates
func NewGetTaskInstanceStatesRequest(server string, params *GetTaskInstanceStatesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/task-instances/states")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dag_id", runtime.ParamLocationQuery, params.DagId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TaskIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "task_ids", runtime.ParamLocationQuery, *params.TaskIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TaskGroupId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "task_group_id", runtime.ParamLocationQuery, *params.TaskGroupId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LogicalDates != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "logical_dates", runtime.ParamLocationQuery, *params.LogicalDates); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RunIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "run_ids", runtime.ParamLocationQuery, *params.RunIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTiHeartbeatRequest calls the generic TiHeartbeat builder with application/json body
func NewTiHeartbeatRequest(server string, taskInstanceId openapi_types.UUID, body TiHeartbeatJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTiHeartbeatRequestWithBody(server, taskInstanceId, "application/json", bodyReader)
}

// NewTiHeartbeatRequestWithBody generates requests for TiHeartbeat with any type of body
func NewTiHeartbeatRequestWithBody(server string, taskInstanceId openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "task_instance_id", runtime.ParamLocationPath, taskInstanceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/task-instances/%s/heartbeat", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPreviousSuccessfulDagrunRequest generates requests for GetPreviousSuccessfulDagrun
func NewGetPreviousSuccessfulDagrunRequest(server string, taskInstanceId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "task_instance_id", runtime.ParamLocationPath, taskInstanceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/task-instances/%s/previous-successful-dagrun", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTiPutRtifRequest calls the generic TiPutRtif builder with application/json body
func NewTiPutRtifRequest(server string, taskInstanceId openapi_types.UUID, body TiPutRtifJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTiPutRtifRequestWithBody(server, taskInstanceId, "application/json", bodyReader)
}

// NewTiPutRtifRequestWithBody generates requests for TiPutRtif with any type of body
func NewTiPutRtifRequestWithBody(server string, taskInstanceId openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "task_instance_id", runtime.ParamLocationPath, taskInstanceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/task-instances/%s/rtif", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTiRunRequest calls the generic TiRun builder with application/json body
func NewTiRunRequest(server string, taskInstanceId openapi_types.UUID, body TiRunJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTiRunRequestWithBody(server, taskInstanceId, "application/json", bodyReader)
}

// NewTiRunRequestWithBody generates requests for TiRun with any type of body
func NewTiRunRequestWithBody(server string, taskInstanceId openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "task_instance_id", runtime.ParamLocationPath, taskInstanceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/task-instances/%s/run", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTiSkipDownstreamRequest calls the generic TiSkipDownstream builder with application/json body
func NewTiSkipDownstreamRequest(server string, taskInstanceId openapi_types.UUID, body TiSkipDownstreamJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTiSkipDownstreamRequestWithBody(server, taskInstanceId, "application/json", bodyReader)
}

// NewTiSkipDownstreamRequestWithBody generates requests for TiSkipDownstream with any type of body
func NewTiSkipDownstreamRequestWithBody(server string, taskInstanceId openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "task_instance_id", runtime.ParamLocationPath, taskInstanceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/task-instances/%s/skip-downstream", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTiUpdateStateRequest calls the generic TiUpdateState builder with application/json body
func NewTiUpdateStateRequest(server string, taskInstanceId openapi_types.UUID, body TiUpdateStateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTiUpdateStateRequestWithBody(server, taskInstanceId, "application/json", bodyReader)
}

// NewTiUpdateStateRequestWithBody generates requests for TiUpdateState with any type of body
func NewTiUpdateStateRequestWithBody(server string, taskInstanceId openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "task_instance_id", runtime.ParamLocationPath, taskInstanceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/task-instances/%s/state", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetStartDateRequest generates requests for GetStartDate
func NewGetStartDateRequest(server string, taskInstanceId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "task_instance_id", runtime.ParamLocationPath, taskInstanceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/task-reschedules/%s/start_date", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteVariableRequest generates requests for DeleteVariable
func NewDeleteVariableRequest(server string, variableKey string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "variable_key", runtime.ParamLocationPath, variableKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/variables/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVariableRequest generates requests for GetVariable
func NewGetVariableRequest(server string, variableKey string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "variable_key", runtime.ParamLocationPath, variableKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/variables/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutVariableRequest calls the generic PutVariable builder with application/json body
func NewPutVariableRequest(server string, variableKey string, body PutVariableJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutVariableRequestWithBody(server, variableKey, "application/json", bodyReader)
}

// NewPutVariableRequestWithBody generates requests for PutVariable with any type of body
func NewPutVariableRequestWithBody(server string, variableKey string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "variable_key", runtime.ParamLocationPath, variableKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/variables/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteXcomRequest generates requests for DeleteXcom
func NewDeleteXcomRequest(server string, dagId string, runId string, taskId string, key string, params *DeleteXcomParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "dag_id", runtime.ParamLocationPath, dagId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "run_id", runtime.ParamLocationPath, runId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "task_id", runtime.ParamLocationPath, taskId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/xcoms/%s/%s/%s/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.MapIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "map_index", runtime.ParamLocationQuery, *params.MapIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetXcomRequest generates requests for GetXcom
func NewGetXcomRequest(server string, dagId string, runId string, taskId string, key string, params *GetXcomParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "dag_id", runtime.ParamLocationPath, dagId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "run_id", runtime.ParamLocationPath, runId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "task_id", runtime.ParamLocationPath, taskId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/xcoms/%s/%s/%s/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.MapIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "map_index", runtime.ParamLocationQuery, *params.MapIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludePriorDates != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_prior_dates", runtime.ParamLocationQuery, *params.IncludePriorDates); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewHeadXcomRequest generates requests for HeadXcom
func NewHeadXcomRequest(server string, dagId string, runId string, taskId string, key string, params *HeadXcomParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "dag_id", runtime.ParamLocationPath, dagId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "run_id", runtime.ParamLocationPath, runId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "task_id", runtime.ParamLocationPath, taskId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/xcoms/%s/%s/%s/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.MapIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "map_index", runtime.ParamLocationQuery, *params.MapIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("HEAD", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetXcomRequest calls the generic SetXcom builder with application/json body
func NewSetXcomRequest(server string, dagId string, runId string, taskId string, key string, params *SetXcomParams, body SetXcomJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetXcomRequestWithBody(server, dagId, runId, taskId, key, params, "application/json", bodyReader)
}

// NewSetXcomRequestWithBody generates requests for SetXcom with any type of body
func NewSetXcomRequestWithBody(server string, dagId string, runId string, taskId string, key string, params *SetXcomParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "dag_id", runtime.ParamLocationPath, dagId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "run_id", runtime.ParamLocationPath, runId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "task_id", runtime.ParamLocationPath, taskId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/xcoms/%s/%s/%s/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.MapIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "map_index", runtime.ParamLocationQuery, *params.MapIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MappedLength != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mapped_length", runtime.ParamLocationQuery, *params.MappedLength); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetAssetEventByAssetNameUriWithResponse request
	GetAssetEventByAssetNameUriWithResponse(ctx context.Context, params *GetAssetEventByAssetNameUriParams, reqEditors ...RequestEditorFn) (*GetAssetEventByAssetNameUriResponse, error)

	// GetAssetEventByAssetAliasWithResponse request
	GetAssetEventByAssetAliasWithResponse(ctx context.Context, params *GetAssetEventByAssetAliasParams, reqEditors ...RequestEditorFn) (*GetAssetEventByAssetAliasResponse, error)

	// GetAssetByNameWithResponse request
	GetAssetByNameWithResponse(ctx context.Context, params *GetAssetByNameParams, reqEditors ...RequestEditorFn) (*GetAssetByNameResponse, error)

	// GetAssetByUriWithResponse request
	GetAssetByUriWithResponse(ctx context.Context, params *GetAssetByUriParams, reqEditors ...RequestEditorFn) (*GetAssetByUriResponse, error)

	// GetConnectionWithResponse request
	GetConnectionWithResponse(ctx context.Context, connectionId string, reqEditors ...RequestEditorFn) (*GetConnectionResponse, error)

	// GetDrCountWithResponse request
	GetDrCountWithResponse(ctx context.Context, params *GetDrCountParams, reqEditors ...RequestEditorFn) (*GetDrCountResponse, error)

	// TriggerDagRunWithBodyWithResponse request with any body
	TriggerDagRunWithBodyWithResponse(ctx context.Context, dagId string, runId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TriggerDagRunResponse, error)

	TriggerDagRunWithResponse(ctx context.Context, dagId string, runId string, body TriggerDagRunJSONRequestBody, reqEditors ...RequestEditorFn) (*TriggerDagRunResponse, error)

	// ClearDagRunWithResponse request
	ClearDagRunWithResponse(ctx context.Context, dagId string, runId string, reqEditors ...RequestEditorFn) (*ClearDagRunResponse, error)

	// GetDagrunStateWithResponse request
	GetDagrunStateWithResponse(ctx context.Context, dagId string, runId string, reqEditors ...RequestEditorFn) (*GetDagrunStateResponse, error)

	// GetTaskInstanceCountWithResponse request
	GetTaskInstanceCountWithResponse(ctx context.Context, params *GetTaskInstanceCountParams, reqEditors ...RequestEditorFn) (*GetTaskInstanceCountResponse, error)

	// GetTaskInstanceStatesWithResponse request
	GetTaskInstanceStatesWithResponse(ctx context.Context, params *GetTaskInstanceStatesParams, reqEditors ...RequestEditorFn) (*GetTaskInstanceStatesResponse, error)

	// TiHeartbeatWithBodyWithResponse request with any body
	TiHeartbeatWithBodyWithResponse(ctx context.Context, taskInstanceId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TiHeartbeatResponse, error)

	TiHeartbeatWithResponse(ctx context.Context, taskInstanceId openapi_types.UUID, body TiHeartbeatJSONRequestBody, reqEditors ...RequestEditorFn) (*TiHeartbeatResponse, error)

	// GetPreviousSuccessfulDagrunWithResponse request
	GetPreviousSuccessfulDagrunWithResponse(ctx context.Context, taskInstanceId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetPreviousSuccessfulDagrunResponse, error)

	// TiPutRtifWithBodyWithResponse request with any body
	TiPutRtifWithBodyWithResponse(ctx context.Context, taskInstanceId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TiPutRtifResponse, error)

	TiPutRtifWithResponse(ctx context.Context, taskInstanceId openapi_types.UUID, body TiPutRtifJSONRequestBody, reqEditors ...RequestEditorFn) (*TiPutRtifResponse, error)

	// TiRunWithBodyWithResponse request with any body
	TiRunWithBodyWithResponse(ctx context.Context, taskInstanceId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TiRunResponse, error)

	TiRunWithResponse(ctx context.Context, taskInstanceId openapi_types.UUID, body TiRunJSONRequestBody, reqEditors ...RequestEditorFn) (*TiRunResponse, error)

	// TiSkipDownstreamWithBodyWithResponse request with any body
	TiSkipDownstreamWithBodyWithResponse(ctx context.Context, taskInstanceId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TiSkipDownstreamResponse, error)

	TiSkipDownstreamWithResponse(ctx context.Context, taskInstanceId openapi_types.UUID, body TiSkipDownstreamJSONRequestBody, reqEditors ...RequestEditorFn) (*TiSkipDownstreamResponse, error)

	// TiUpdateStateWithBodyWithResponse request with any body
	TiUpdateStateWithBodyWithResponse(ctx context.Context, taskInstanceId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TiUpdateStateResponse, error)

	TiUpdateStateWithResponse(ctx context.Context, taskInstanceId openapi_types.UUID, body TiUpdateStateJSONRequestBody, reqEditors ...RequestEditorFn) (*TiUpdateStateResponse, error)

	// GetStartDateWithResponse request
	GetStartDateWithResponse(ctx context.Context, taskInstanceId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetStartDateResponse, error)

	// DeleteVariableWithResponse request
	DeleteVariableWithResponse(ctx context.Context, variableKey string, reqEditors ...RequestEditorFn) (*DeleteVariableResponse, error)

	// GetVariableWithResponse request
	GetVariableWithResponse(ctx context.Context, variableKey string, reqEditors ...RequestEditorFn) (*GetVariableResponse, error)

	// PutVariableWithBodyWithResponse request with any body
	PutVariableWithBodyWithResponse(ctx context.Context, variableKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutVariableResponse, error)

	PutVariableWithResponse(ctx context.Context, variableKey string, body PutVariableJSONRequestBody, reqEditors ...RequestEditorFn) (*PutVariableResponse, error)

	// DeleteXcomWithResponse request
	DeleteXcomWithResponse(ctx context.Context, dagId string, runId string, taskId string, key string, params *DeleteXcomParams, reqEditors ...RequestEditorFn) (*DeleteXcomResponse, error)

	// GetXcomWithResponse request
	GetXcomWithResponse(ctx context.Context, dagId string, runId string, taskId string, key string, params *GetXcomParams, reqEditors ...RequestEditorFn) (*GetXcomResponse, error)

	// HeadXcomWithResponse request
	HeadXcomWithResponse(ctx context.Context, dagId string, runId string, taskId string, key string, params *HeadXcomParams, reqEditors ...RequestEditorFn) (*HeadXcomResponse, error)

	// SetXcomWithBodyWithResponse request with any body
	SetXcomWithBodyWithResponse(ctx context.Context, dagId string, runId string, taskId string, key string, params *SetXcomParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetXcomResponse, error)

	SetXcomWithResponse(ctx context.Context, dagId string, runId string, taskId string, key string, params *SetXcomParams, body SetXcomJSONRequestBody, reqEditors ...RequestEditorFn) (*SetXcomResponse, error)
}

type GetAssetEventByAssetNameUriResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AssetEventsResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r GetAssetEventByAssetNameUriResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAssetEventByAssetNameUriResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAssetEventByAssetAliasResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AssetEventsResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r GetAssetEventByAssetAliasResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAssetEventByAssetAliasResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAssetByNameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AssetResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r GetAssetByNameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAssetByNameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAssetByUriResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AssetResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r GetAssetByUriResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAssetByUriResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetConnectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConnectionResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r GetConnectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConnectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDrCountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *int
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r GetDrCountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDrCountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TriggerDagRunResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TriggerDagRunResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TriggerDagRunResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ClearDagRunResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ClearDagRunResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ClearDagRunResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDagrunStateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DagRunStateResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r GetDagrunStateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDagrunStateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTaskInstanceCountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *int
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r GetTaskInstanceCountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTaskInstanceCountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTaskInstanceStatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TaskStatesResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r GetTaskInstanceStatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTaskInstanceStatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TiHeartbeatResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TiHeartbeatResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TiHeartbeatResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPreviousSuccessfulDagrunResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PrevSuccessfulDagRunResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r GetPreviousSuccessfulDagrunResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPreviousSuccessfulDagrunResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TiPutRtifResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *interface{}
}

// Status returns HTTPResponse.Status
func (r TiPutRtifResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TiPutRtifResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TiRunResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TIRunContext
}

// Status returns HTTPResponse.Status
func (r TiRunResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TiRunResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TiSkipDownstreamResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TiSkipDownstreamResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TiSkipDownstreamResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TiUpdateStateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TiUpdateStateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TiUpdateStateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStartDateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *time.Time
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r GetStartDateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStartDateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteVariableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r DeleteVariableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteVariableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVariableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VariableResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r GetVariableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVariableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutVariableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *interface{}
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r PutVariableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutVariableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteXcomResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r DeleteXcomResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteXcomResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetXcomResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *XComResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r GetXcomResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetXcomResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type HeadXcomResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r HeadXcomResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HeadXcomResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetXcomResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *interface{}
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r SetXcomResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetXcomResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetAssetEventByAssetNameUriWithResponse request returning *GetAssetEventByAssetNameUriResponse
func (c *ClientWithResponses) GetAssetEventByAssetNameUriWithResponse(ctx context.Context, params *GetAssetEventByAssetNameUriParams, reqEditors ...RequestEditorFn) (*GetAssetEventByAssetNameUriResponse, error) {
	rsp, err := c.GetAssetEventByAssetNameUri(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAssetEventByAssetNameUriResponse(rsp)
}

// GetAssetEventByAssetAliasWithResponse request returning *GetAssetEventByAssetAliasResponse
func (c *ClientWithResponses) GetAssetEventByAssetAliasWithResponse(ctx context.Context, params *GetAssetEventByAssetAliasParams, reqEditors ...RequestEditorFn) (*GetAssetEventByAssetAliasResponse, error) {
	rsp, err := c.GetAssetEventByAssetAlias(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAssetEventByAssetAliasResponse(rsp)
}

// GetAssetByNameWithResponse request returning *GetAssetByNameResponse
func (c *ClientWithResponses) GetAssetByNameWithResponse(ctx context.Context, params *GetAssetByNameParams, reqEditors ...RequestEditorFn) (*GetAssetByNameResponse, error) {
	rsp, err := c.GetAssetByName(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAssetByNameResponse(rsp)
}

// GetAssetByUriWithResponse request returning *GetAssetByUriResponse
func (c *ClientWithResponses) GetAssetByUriWithResponse(ctx context.Context, params *GetAssetByUriParams, reqEditors ...RequestEditorFn) (*GetAssetByUriResponse, error) {
	rsp, err := c.GetAssetByUri(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAssetByUriResponse(rsp)
}

// GetConnectionWithResponse request returning *GetConnectionResponse
func (c *ClientWithResponses) GetConnectionWithResponse(ctx context.Context, connectionId string, reqEditors ...RequestEditorFn) (*GetConnectionResponse, error) {
	rsp, err := c.GetConnection(ctx, connectionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetConnectionResponse(rsp)
}

// GetDrCountWithResponse request returning *GetDrCountResponse
func (c *ClientWithResponses) GetDrCountWithResponse(ctx context.Context, params *GetDrCountParams, reqEditors ...RequestEditorFn) (*GetDrCountResponse, error) {
	rsp, err := c.GetDrCount(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDrCountResponse(rsp)
}

// TriggerDagRunWithBodyWithResponse request with arbitrary body returning *TriggerDagRunResponse
func (c *ClientWithResponses) TriggerDagRunWithBodyWithResponse(ctx context.Context, dagId string, runId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TriggerDagRunResponse, error) {
	rsp, err := c.TriggerDagRunWithBody(ctx, dagId, runId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTriggerDagRunResponse(rsp)
}

func (c *ClientWithResponses) TriggerDagRunWithResponse(ctx context.Context, dagId string, runId string, body TriggerDagRunJSONRequestBody, reqEditors ...RequestEditorFn) (*TriggerDagRunResponse, error) {
	rsp, err := c.TriggerDagRun(ctx, dagId, runId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTriggerDagRunResponse(rsp)
}

// ClearDagRunWithResponse request returning *ClearDagRunResponse
func (c *ClientWithResponses) ClearDagRunWithResponse(ctx context.Context, dagId string, runId string, reqEditors ...RequestEditorFn) (*ClearDagRunResponse, error) {
	rsp, err := c.ClearDagRun(ctx, dagId, runId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseClearDagRunResponse(rsp)
}

// GetDagrunStateWithResponse request returning *GetDagrunStateResponse
func (c *ClientWithResponses) GetDagrunStateWithResponse(ctx context.Context, dagId string, runId string, reqEditors ...RequestEditorFn) (*GetDagrunStateResponse, error) {
	rsp, err := c.GetDagrunState(ctx, dagId, runId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDagrunStateResponse(rsp)
}

// GetTaskInstanceCountWithResponse request returning *GetTaskInstanceCountResponse
func (c *ClientWithResponses) GetTaskInstanceCountWithResponse(ctx context.Context, params *GetTaskInstanceCountParams, reqEditors ...RequestEditorFn) (*GetTaskInstanceCountResponse, error) {
	rsp, err := c.GetTaskInstanceCount(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTaskInstanceCountResponse(rsp)
}

// GetTaskInstanceStatesWithResponse request returning *GetTaskInstanceStatesResponse
func (c *ClientWithResponses) GetTaskInstanceStatesWithResponse(ctx context.Context, params *GetTaskInstanceStatesParams, reqEditors ...RequestEditorFn) (*GetTaskInstanceStatesResponse, error) {
	rsp, err := c.GetTaskInstanceStates(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTaskInstanceStatesResponse(rsp)
}

// TiHeartbeatWithBodyWithResponse request with arbitrary body returning *TiHeartbeatResponse
func (c *ClientWithResponses) TiHeartbeatWithBodyWithResponse(ctx context.Context, taskInstanceId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TiHeartbeatResponse, error) {
	rsp, err := c.TiHeartbeatWithBody(ctx, taskInstanceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTiHeartbeatResponse(rsp)
}

func (c *ClientWithResponses) TiHeartbeatWithResponse(ctx context.Context, taskInstanceId openapi_types.UUID, body TiHeartbeatJSONRequestBody, reqEditors ...RequestEditorFn) (*TiHeartbeatResponse, error) {
	rsp, err := c.TiHeartbeat(ctx, taskInstanceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTiHeartbeatResponse(rsp)
}

// GetPreviousSuccessfulDagrunWithResponse request returning *GetPreviousSuccessfulDagrunResponse
func (c *ClientWithResponses) GetPreviousSuccessfulDagrunWithResponse(ctx context.Context, taskInstanceId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetPreviousSuccessfulDagrunResponse, error) {
	rsp, err := c.GetPreviousSuccessfulDagrun(ctx, taskInstanceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPreviousSuccessfulDagrunResponse(rsp)
}

// TiPutRtifWithBodyWithResponse request with arbitrary body returning *TiPutRtifResponse
func (c *ClientWithResponses) TiPutRtifWithBodyWithResponse(ctx context.Context, taskInstanceId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TiPutRtifResponse, error) {
	rsp, err := c.TiPutRtifWithBody(ctx, taskInstanceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTiPutRtifResponse(rsp)
}

func (c *ClientWithResponses) TiPutRtifWithResponse(ctx context.Context, taskInstanceId openapi_types.UUID, body TiPutRtifJSONRequestBody, reqEditors ...RequestEditorFn) (*TiPutRtifResponse, error) {
	rsp, err := c.TiPutRtif(ctx, taskInstanceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTiPutRtifResponse(rsp)
}

// TiRunWithBodyWithResponse request with arbitrary body returning *TiRunResponse
func (c *ClientWithResponses) TiRunWithBodyWithResponse(ctx context.Context, taskInstanceId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TiRunResponse, error) {
	rsp, err := c.TiRunWithBody(ctx, taskInstanceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTiRunResponse(rsp)
}

func (c *ClientWithResponses) TiRunWithResponse(ctx context.Context, taskInstanceId openapi_types.UUID, body TiRunJSONRequestBody, reqEditors ...RequestEditorFn) (*TiRunResponse, error) {
	rsp, err := c.TiRun(ctx, taskInstanceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTiRunResponse(rsp)
}

// TiSkipDownstreamWithBodyWithResponse request with arbitrary body returning *TiSkipDownstreamResponse
func (c *ClientWithResponses) TiSkipDownstreamWithBodyWithResponse(ctx context.Context, taskInstanceId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TiSkipDownstreamResponse, error) {
	rsp, err := c.TiSkipDownstreamWithBody(ctx, taskInstanceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTiSkipDownstreamResponse(rsp)
}

func (c *ClientWithResponses) TiSkipDownstreamWithResponse(ctx context.Context, taskInstanceId openapi_types.UUID, body TiSkipDownstreamJSONRequestBody, reqEditors ...RequestEditorFn) (*TiSkipDownstreamResponse, error) {
	rsp, err := c.TiSkipDownstream(ctx, taskInstanceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTiSkipDownstreamResponse(rsp)
}

// TiUpdateStateWithBodyWithResponse request with arbitrary body returning *TiUpdateStateResponse
func (c *ClientWithResponses) TiUpdateStateWithBodyWithResponse(ctx context.Context, taskInstanceId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TiUpdateStateResponse, error) {
	rsp, err := c.TiUpdateStateWithBody(ctx, taskInstanceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTiUpdateStateResponse(rsp)
}

func (c *ClientWithResponses) TiUpdateStateWithResponse(ctx context.Context, taskInstanceId openapi_types.UUID, body TiUpdateStateJSONRequestBody, reqEditors ...RequestEditorFn) (*TiUpdateStateResponse, error) {
	rsp, err := c.TiUpdateState(ctx, taskInstanceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTiUpdateStateResponse(rsp)
}

// GetStartDateWithResponse request returning *GetStartDateResponse
func (c *ClientWithResponses) GetStartDateWithResponse(ctx context.Context, taskInstanceId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetStartDateResponse, error) {
	rsp, err := c.GetStartDate(ctx, taskInstanceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStartDateResponse(rsp)
}

// DeleteVariableWithResponse request returning *DeleteVariableResponse
func (c *ClientWithResponses) DeleteVariableWithResponse(ctx context.Context, variableKey string, reqEditors ...RequestEditorFn) (*DeleteVariableResponse, error) {
	rsp, err := c.DeleteVariable(ctx, variableKey, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteVariableResponse(rsp)
}

// GetVariableWithResponse request returning *GetVariableResponse
func (c *ClientWithResponses) GetVariableWithResponse(ctx context.Context, variableKey string, reqEditors ...RequestEditorFn) (*GetVariableResponse, error) {
	rsp, err := c.GetVariable(ctx, variableKey, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVariableResponse(rsp)
}

// PutVariableWithBodyWithResponse request with arbitrary body returning *PutVariableResponse
func (c *ClientWithResponses) PutVariableWithBodyWithResponse(ctx context.Context, variableKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutVariableResponse, error) {
	rsp, err := c.PutVariableWithBody(ctx, variableKey, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutVariableResponse(rsp)
}

func (c *ClientWithResponses) PutVariableWithResponse(ctx context.Context, variableKey string, body PutVariableJSONRequestBody, reqEditors ...RequestEditorFn) (*PutVariableResponse, error) {
	rsp, err := c.PutVariable(ctx, variableKey, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutVariableResponse(rsp)
}

// DeleteXcomWithResponse request returning *DeleteXcomResponse
func (c *ClientWithResponses) DeleteXcomWithResponse(ctx context.Context, dagId string, runId string, taskId string, key string, params *DeleteXcomParams, reqEditors ...RequestEditorFn) (*DeleteXcomResponse, error) {
	rsp, err := c.DeleteXcom(ctx, dagId, runId, taskId, key, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteXcomResponse(rsp)
}

// GetXcomWithResponse request returning *GetXcomResponse
func (c *ClientWithResponses) GetXcomWithResponse(ctx context.Context, dagId string, runId string, taskId string, key string, params *GetXcomParams, reqEditors ...RequestEditorFn) (*GetXcomResponse, error) {
	rsp, err := c.GetXcom(ctx, dagId, runId, taskId, key, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetXcomResponse(rsp)
}

// HeadXcomWithResponse request returning *HeadXcomResponse
func (c *ClientWithResponses) HeadXcomWithResponse(ctx context.Context, dagId string, runId string, taskId string, key string, params *HeadXcomParams, reqEditors ...RequestEditorFn) (*HeadXcomResponse, error) {
	rsp, err := c.HeadXcom(ctx, dagId, runId, taskId, key, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHeadXcomResponse(rsp)
}

// SetXcomWithBodyWithResponse request with arbitrary body returning *SetXcomResponse
func (c *ClientWithResponses) SetXcomWithBodyWithResponse(ctx context.Context, dagId string, runId string, taskId string, key string, params *SetXcomParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetXcomResponse, error) {
	rsp, err := c.SetXcomWithBody(ctx, dagId, runId, taskId, key, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetXcomResponse(rsp)
}

func (c *ClientWithResponses) SetXcomWithResponse(ctx context.Context, dagId string, runId string, taskId string, key string, params *SetXcomParams, body SetXcomJSONRequestBody, reqEditors ...RequestEditorFn) (*SetXcomResponse, error) {
	rsp, err := c.SetXcom(ctx, dagId, runId, taskId, key, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetXcomResponse(rsp)
}

// ParseGetAssetEventByAssetNameUriResponse parses an HTTP response from a GetAssetEventByAssetNameUriWithResponse call
func ParseGetAssetEventByAssetNameUriResponse(rsp *http.Response) (*GetAssetEventByAssetNameUriResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAssetEventByAssetNameUriResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AssetEventsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetAssetEventByAssetAliasResponse parses an HTTP response from a GetAssetEventByAssetAliasWithResponse call
func ParseGetAssetEventByAssetAliasResponse(rsp *http.Response) (*GetAssetEventByAssetAliasResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAssetEventByAssetAliasResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AssetEventsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetAssetByNameResponse parses an HTTP response from a GetAssetByNameWithResponse call
func ParseGetAssetByNameResponse(rsp *http.Response) (*GetAssetByNameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAssetByNameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AssetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetAssetByUriResponse parses an HTTP response from a GetAssetByUriWithResponse call
func ParseGetAssetByUriResponse(rsp *http.Response) (*GetAssetByUriResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAssetByUriResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AssetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetConnectionResponse parses an HTTP response from a GetConnectionWithResponse call
func ParseGetConnectionResponse(rsp *http.Response) (*GetConnectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetConnectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConnectionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetDrCountResponse parses an HTTP response from a GetDrCountWithResponse call
func ParseGetDrCountResponse(rsp *http.Response) (*GetDrCountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDrCountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest int
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseTriggerDagRunResponse parses an HTTP response from a TriggerDagRunWithResponse call
func ParseTriggerDagRunResponse(rsp *http.Response) (*TriggerDagRunResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TriggerDagRunResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseClearDagRunResponse parses an HTTP response from a ClearDagRunWithResponse call
func ParseClearDagRunResponse(rsp *http.Response) (*ClearDagRunResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ClearDagRunResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetDagrunStateResponse parses an HTTP response from a GetDagrunStateWithResponse call
func ParseGetDagrunStateResponse(rsp *http.Response) (*GetDagrunStateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDagrunStateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DagRunStateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetTaskInstanceCountResponse parses an HTTP response from a GetTaskInstanceCountWithResponse call
func ParseGetTaskInstanceCountResponse(rsp *http.Response) (*GetTaskInstanceCountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTaskInstanceCountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest int
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetTaskInstanceStatesResponse parses an HTTP response from a GetTaskInstanceStatesWithResponse call
func ParseGetTaskInstanceStatesResponse(rsp *http.Response) (*GetTaskInstanceStatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTaskInstanceStatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TaskStatesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseTiHeartbeatResponse parses an HTTP response from a TiHeartbeatWithResponse call
func ParseTiHeartbeatResponse(rsp *http.Response) (*TiHeartbeatResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TiHeartbeatResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPreviousSuccessfulDagrunResponse parses an HTTP response from a GetPreviousSuccessfulDagrunWithResponse call
func ParseGetPreviousSuccessfulDagrunResponse(rsp *http.Response) (*GetPreviousSuccessfulDagrunResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPreviousSuccessfulDagrunResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PrevSuccessfulDagRunResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseTiPutRtifResponse parses an HTTP response from a TiPutRtifWithResponse call
func ParseTiPutRtifResponse(rsp *http.Response) (*TiPutRtifResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TiPutRtifResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseTiRunResponse parses an HTTP response from a TiRunWithResponse call
func ParseTiRunResponse(rsp *http.Response) (*TiRunResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TiRunResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TIRunContext
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTiSkipDownstreamResponse parses an HTTP response from a TiSkipDownstreamWithResponse call
func ParseTiSkipDownstreamResponse(rsp *http.Response) (*TiSkipDownstreamResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TiSkipDownstreamResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTiUpdateStateResponse parses an HTTP response from a TiUpdateStateWithResponse call
func ParseTiUpdateStateResponse(rsp *http.Response) (*TiUpdateStateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TiUpdateStateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetStartDateResponse parses an HTTP response from a GetStartDateWithResponse call
func ParseGetStartDateResponse(rsp *http.Response) (*GetStartDateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStartDateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest time.Time
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseDeleteVariableResponse parses an HTTP response from a DeleteVariableWithResponse call
func ParseDeleteVariableResponse(rsp *http.Response) (*DeleteVariableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteVariableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetVariableResponse parses an HTTP response from a GetVariableWithResponse call
func ParseGetVariableResponse(rsp *http.Response) (*GetVariableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVariableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VariableResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParsePutVariableResponse parses an HTTP response from a PutVariableWithResponse call
func ParsePutVariableResponse(rsp *http.Response) (*PutVariableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutVariableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseDeleteXcomResponse parses an HTTP response from a DeleteXcomWithResponse call
func ParseDeleteXcomResponse(rsp *http.Response) (*DeleteXcomResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteXcomResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetXcomResponse parses an HTTP response from a GetXcomWithResponse call
func ParseGetXcomResponse(rsp *http.Response) (*GetXcomResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetXcomResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest XComResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseHeadXcomResponse parses an HTTP response from a HeadXcomWithResponse call
func ParseHeadXcomResponse(rsp *http.Response) (*HeadXcomResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &HeadXcomResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseSetXcomResponse parses an HTTP response from a SetXcomWithResponse call
func ParseSetXcomResponse(rsp *http.Response) (*SetXcomResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetXcomResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}
