#!/usr/bin/env python
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
# Monkey patch conf.get() to check whether the default value comes from a call to conf.get(...)
from __future__ import annotations

import os
from typing import TYPE_CHECKING, Any, Callable, Literal, TextIO

from airflow.cli.cli_config import ActionCommand, Arg, GroupCommand
from airflow.executors.executor_constants import CORE_EXECUTOR_NAMES as AVAILABLE_EXECUTORS, MOCK_EXECUTOR
from airflow.executors.executor_loader import ExecutorLoader
from airflow.utils.module_loading import import_string

# from airflow.auth.managers.manager_constants import CORE_AUTH_MANAGER_NAMES as AVAILABLE_AUTH_MANAGERS

if TYPE_CHECKING:
    from airflow.cli.cli_config import CLICommand

SIMPLE_AUTH_MANAGER = "airflow.auth.managers.simple.simple_auth_manager.SimpleAuthManager"
FAB_AUTH_MANAGER = "airflow.providers.fab.auth_manager.fab_auth_manager.FabAuthManager"
AWS_AUTH_MANAGER = "airflow.providers.amazon.aws.auth_manager.aws_auth_manager.AwsAuthManager"
AVAILABLE_AUTH_MANAGERS = [
    SIMPLE_AUTH_MANAGER,
    FAB_AUTH_MANAGER,
    AWS_AUTH_MANAGER,
]

TARGET_GENERATED_FILE = "airflow/cli/commands/_generated_commands.py"
TARGET_VAR_AUTH_MANAGERS = "AUTH_MANAGERS_CLI_COMMANDS"
TARGET_VAR_EXECUTORS = "EXECUTORS_CLI_COMMANDS"
LAZY_LOAD_COMMAND = "lazy_load_command"
TARGET_VAR_TYPE = "dict[ str , list[CLICommand]"

HEADER_TEMPLATE = """
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
#
# DO NOT MODIFY THIS FILE DIRECTLY
# IT IS AUTOGENERATED BY scripts/ci/pre_commit/generate_cli_commands_for_auth_managers_executors.py
# RUN `pre-commit run generate-cli-commands-for-auth-managers-executors` TO UPDATE

from __future__ import annotations

from airflow.cli.cli_config import (
    ActionCommand,
    Arg,
    GroupCommand,
    lazy_load_command,
    positive_int,
)
from airflow.configuration import conf
from airflow.utils.timezone import parse as timeparse

"""


def override_env():
    # executor
    os.environ["AIRFLOW__CORE__EXECUTOR"] = ",".join(
        [executor for executor in AVAILABLE_EXECUTORS if executor != MOCK_EXECUTOR]
    )
    # auth manager
    os.environ["AIRFLOW__AWS_AUTH_MANAGER__CONN_ID"] = "aws_default"
    os.environ["AIRFLOW__AWS_AUTH_MANAGER__REGION_NAME"] = "us-west-2"
    os.environ["AIRFLOW__AWS_AUTH_MANAGER__AVP_POLICY_STORE_ID"] = "avp_policy_store_id"


def monkey_patch_auth_managers():
    aws_auth_manager = import_string(AWS_AUTH_MANAGER)
    # skip _check_avp_schema_version when construct, since we just need to call `get_cli_commands`
    aws_auth_manager._check_avp_schema_version = lambda self: None


def monkey_patch_conf():
    """Monkey patch `conf.get*` to trace the source of the default value of an argument."""
    from airflow.configuration import conf

    class StrWrapper(str):
        """A subclass of `str` that has a `__conf_source__` attribute."""

        def __new__(cls, value, conf_source=None):
            obj = super().__new__(cls, value)
            obj.__conf_source__ = conf_source
            return obj

        def __repr__(self):
            return (
                f"{super().__repr__()} (from {self.__conf_source__})"
                if self.__conf_source__
                else super().__repr__()
            )

    class IntWrapper(int):
        """A subclass of `int` that has a `__conf_source__` attribute."""

        def __new__(cls, value, conf_source=None):
            obj = super().__new__(cls, value)
            obj.__conf_source__ = conf_source
            return obj

        def __repr__(self):
            return (
                f"{super().__repr__()} (from {self.__conf_source__})"
                if self.__conf_source__
                else super().__repr__()
            )

    class BoolWrapper:
        """A wrapper of `bool` that has a `__conf_source__` attribute."""

        def __init__(self, value, conf_source=None):
            self.value = value
            self.__conf_source__ = conf_source

        def __bool__(self):
            return self.value  # Ensures it behaves like a bool

        def __repr__(self):
            return (
                f"{super().__repr__()} (from {self.__conf_source__})"
                if self.__conf_source__
                else super().__repr__()
            )

    class ListWrapper(list):
        """A wrapper of `list` that has a `__conf_source__` attribute."""

        def __init__(self, value, conf_source=None):
            super().__init__(value)
            self.__conf_source__ = conf_source

        def __repr__(self):
            return (
                f"{super().__repr__()} (from {self.__conf_source__})"
                if self.__conf_source__
                else super().__repr__()
            )

    def _trace_conf_get_decorator(
        func: Callable, trace_cls: type, method_name: Literal["get", "getint", "getboolean", "getlist"]
    ):
        """Decorator to trace the source of the default value of an argument.

        Set `__conf_source__` attribute to the return value of `conf.get(...)`.
        """

        def wrapper(*args, **kwargs):
            default_value: Any = func(*args, **kwargs)
            section = args[0] if len(args) > 0 else kwargs.get("section")
            key = args[1] if len(args) > 1 else kwargs.get("key")
            print(f"calling conf.{method_name}({section!r}, {key!r})")
            if default_value is not None:
                print(f"conf.{method_name}({section!r}, {key!r}) -> {default_value}")
                default_value = trace_cls(default_value, f"conf.{method_name}({section!r}, {key!r})")
                print(f"modified default value: {default_value}")
            return default_value

        return wrapper

    conf.get = _trace_conf_get_decorator(conf.get, StrWrapper, "get")
    conf.getint = _trace_conf_get_decorator(conf.getint, IntWrapper, "getint")
    conf.getboolean = _trace_conf_get_decorator(conf.getboolean, BoolWrapper, "getboolean")
    conf.getlist = _trace_conf_get_decorator(conf.getlist, ListWrapper, "getlist")


def get_auth_managers_cli_commands() -> dict[str, list[CLICommand]]:
    auth_manager_cli_commands = {}
    for auth_manager_module_path in AVAILABLE_AUTH_MANAGERS:
        auth_manager_cls = import_string(auth_manager_module_path)
        auth_manager = auth_manager_cls()
        auth_manager_name = auth_manager.__class__.__name__
        print("Auth manager name: ", auth_manager_name)
        auth_manager_cli_commands[auth_manager_name] = auth_manager.get_cli_commands()

    return auth_manager_cli_commands


def get_executors_cli_commands() -> dict[str, list[CLICommand]]:
    executor_cli_commands = {}
    loaded_executors = ExecutorLoader.init_executors()
    print("Loaded executors: ", loaded_executors)
    for executor in loaded_executors:
        executor_name = executor.__class__.__name__
        print("Executor name: ", executor_name)
        executor_cli_commands[executor_name] = executor.get_cli_commands()

    return executor_cli_commands


def serialize_action_func(func: Callable) -> str:
    freevars = dict(zip(func.__code__.co_freevars, (c.cell_contents for c in (func.__closure__ or ()))))
    func_path = freevars["import_path"]
    return f"lazy_load_command('{func_path}')"


def serialize_arg_type(arg_type: type | Callable) -> str:
    print("Arg type: ", arg_type)
    if hasattr(arg_type, "__module__") and arg_type.__module__ == "builtins":
        return arg_type.__name__
    elif hasattr(arg_type, "__module__") and arg_type.__module__ == "airflow.utils.timezone":
        return "timeparse"
    elif hasattr(arg_type, "__module__") and arg_type.__module__ == "airflow.cli.cli_config":
        # The arg_type will be one of positive_int, string_list_type, string_lower_type
        print("type(arg_type): ", type(arg_type))
        # If the arg_type is generated by positive_int, its __name__ is '_check', so check its closure for 'allow_zero'
        if arg_type.__name__ == "_check" and arg_type.__code__.co_freevars:
            freevars = dict(
                zip(arg_type.__code__.co_freevars, (c.cell_contents for c in (arg_type.__closure__ or ())))
            )
            if "allow_zero" in freevars:
                return f"positive_int(allow_zero={freevars['allow_zero']})"
        return arg_type.__name__
    else:
        return arg_type.__name__


def trace_default_value(default_value: Any) -> str:
    if hasattr(default_value, "__conf_source__"):
        # the default value comes from a call to conf.get(...)
        return default_value.__conf_source__
    return repr(default_value)


def serialize_optional_str_field(value: str | None = None) -> str:
    if not value:
        return "None"
    # handle multiline strings
    if "\n" in value:
        return f'"""{value}"""'
    return f'"{value}"'


def serialize_arg(arg: Arg) -> str:
    arg_attrs = [f"Arg(flags={arg.flags}"]
    for key, value in arg.kwargs.items():
        if key == "type":
            arg_attrs.append(f"{key}={serialize_arg_type(value)}")
        elif key == "default":
            arg_attrs.append(f"{key}={trace_default_value(value)}")
        elif key == "choices":
            arg_attrs.append(f"{key}={value!r}")
        elif isinstance(value, str) or value is None:
            arg_attrs.append(f"{key}={serialize_optional_str_field(value)}")
        else:
            arg_attrs.append(f'{key}="{value}"')
    return ", ".join(arg_attrs) + ")"


def serialize_action_command(action_command: ActionCommand) -> str:
    serialized_args = (
        ", ".join([serialize_arg(arg) for arg in action_command.args]) if action_command.args else ""
    )
    return f"""
    ActionCommand(
        name="{action_command.name}",
        help="{action_command.help}",
        func={serialize_action_func(action_command.func)},
        args=[{serialized_args}],
        description={serialize_optional_str_field(action_command.description)},
        epilog={serialize_optional_str_field(action_command.epilog)},
        hide={action_command.hide}
    )"""


def serialize_group_command(group_command: GroupCommand) -> str:
    serialized_subcommands = (
        ", ".join([serialize_action_command(subcommand) for subcommand in group_command.subcommands])
        if group_command.subcommands
        else ""
    )
    return f"""
    GroupCommand(
        name="{group_command.name}",
        help="{group_command.help}",
        subcommands=[{serialized_subcommands}],
        description={serialize_optional_str_field(group_command.description)},
        epilog={serialize_optional_str_field(group_command.epilog)},
    )"""


def write_cli_commands(cli_commands: dict[str, list[CLICommand]], target_var: str, target_file: TextIO):
    target_file.write(target_var + " = {\n")
    for name, commands in cli_commands.items():
        target_file.write(f"    '{name}': [\n")
        for command in commands:
            if isinstance(command, ActionCommand):
                target_file.write(f"        {serialize_action_command(command)},\n")
            elif isinstance(command, GroupCommand):
                target_file.write(f"        {serialize_group_command(command)},\n")
        target_file.write("    ],\n")
    target_file.write("}\n")


if __name__ == "__main__":
    override_env()
    monkey_patch_auth_managers()
    monkey_patch_conf()

    executors_cli_commands = get_executors_cli_commands()
    auth_managers_cli_commands = get_auth_managers_cli_commands()

    with open(TARGET_GENERATED_FILE, "w") as target_file:
        target_file.write(HEADER_TEMPLATE)
        write_cli_commands(executors_cli_commands, TARGET_VAR_EXECUTORS, target_file)
        write_cli_commands(auth_managers_cli_commands, TARGET_VAR_AUTH_MANAGERS, target_file)
