#!/usr/bin/env python
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
"""
Module to convert Airflow configs in config.yml to default_airflow.cfg file
"""
from __future__ import annotations

import os
import sys
from pathlib import Path
from typing import Any

import yaml
from rich.console import Console

sys.path.insert(0, str(Path(__file__).parent.resolve()))  # make sure common_precommit_utils is imported
from common_precommit_utils import (  # noqa: E402
    AIRFLOW_SOURCES_ROOT,
    black_format,
    render_template_from_string,
)

console = Console(force_terminal=True, color_system="standard", width=400)

PYTHON_BUILT_IN_DEFAULTS_PATH = AIRFLOW_SOURCES_ROOT / "airflow" / "config_templates" / "built_in_defaults.py"

FILE_HEADER = """#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.

# This is the template for Airflow's default configuration. When Airflow is
# imported, it looks for a configuration file at $AIRFLOW_HOME/airflow.cfg. If
# it doesn't exist, Airflow uses this template to generate it by replacing
# variables in curly braces with their global values from configuration.py.

# Users should not modify this file; they should customize the generated
# airflow.cfg instead.


# ----------------------- TEMPLATE BEGINS HERE -----------------------
"""

PYTHON_BUILT_IN_DEFAULTS_CONTENT = """#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.

# Those are built-in defaults for Airflow's default configuration. When there
# are no defaults stored in airflow configuration file, those defaults are used
# as a fallback for the configuration values
#
# PLEASE DO NOT MODIFY THIS FILE IT IS AUTOGENERATED FROM THE CONFIGURATION.YAML FILE
from __future__ import annotations

built_in_defaults: dict[str, dict[str, str]] = {{ config_defaults_dict }}
"""


def read_default_config_yaml(file_path: Path) -> dict:
    """
    Read Airflow configs from YAML file

    :param file_path: Full path to config.yaml

    :return: Python dictionary containing configs & their info
    """

    with open(file_path) as config_file:
        return yaml.safe_load(config_file)


def write_config(
    yaml_config_file_path: Path, default_cfg_file_path: Path, built_in_defaults_file_path: Path | None
):
    """
    Write config to default_airflow.cfg file

    :param yaml_config_file_path: Path to config.yaml
    :param default_cfg_file_path: Path to default_airflow.cfg
    :param built_in_defaults_file_path: Path to built_in_defaults.py
    """
    console.print(f"[blue]Converting:[/] {yaml_config_file_path} to {default_cfg_file_path}")
    config_yaml = read_default_config_yaml(yaml_config_file_path)
    with open(default_cfg_file_path, "w") as configfile:
        configfile.writelines(FILE_HEADER)

        for section_name, section in config_yaml.items():
            _write_section(configfile, section_name, section)

    if built_in_defaults_file_path:
        print(f"[blue]Also preparing:[/] {built_in_defaults_file_path}")
        config_defaults_dict = {}
        for section in config_yaml:
            section_dict: dict[str, Any] = {}
            config_defaults_dict[section] = section_dict
            options = config_yaml[section]["options"]
            for option in options:
                if options[option]["default"] is not None:
                    if (
                        option in ["log_filename_template", "log_processor_filename_template"]
                        and section == "logging"
                    ):
                        section_dict[option] = (
                            options[option]["default"].replace("{{", "{").replace("}}", "}")
                        )
                    else:
                        section_dict[option] = options[option]["default"]
        built_in_defaults_file_path.write_text(
            black_format(
                render_template_from_string(
                    template_string=PYTHON_BUILT_IN_DEFAULTS_CONTENT,
                    context={"config_defaults_dict": config_defaults_dict},
                    autoescape=False,
                    keep_trailing_newline=True,
                )
            )
        )


def _write_section(configfile, section_name, section):
    configfile.write(f"\n[{section_name}]\n")
    section_description = None
    if section["description"] is not None:
        section_description = list(
            filter(lambda x: (x is not None) or x != "", section["description"].splitlines())
        )
    if section_description:
        configfile.write("\n")
        for single_line_desc in section_description:
            if single_line_desc == "":
                configfile.write("#\n")
            else:
                configfile.write(f"# {single_line_desc}\n")
    for idx, (option_name, option) in enumerate(section["options"].items()):
        _write_option(configfile, idx, option_name, option)


def _write_option(configfile, idx, option_name, option):
    option_description = None
    if option["description"] is not None:
        option_description = list(filter(lambda x: x is not None, option["description"].splitlines()))

    if option_description:
        if idx != 0:
            configfile.write("\n")
        for single_line_desc in option_description:
            if single_line_desc == "":
                configfile.write("#\n")
            else:
                configfile.write(f"# {single_line_desc}\n")

    if option["example"]:
        if not str(option_name).endswith("_template"):
            option["example"] = option["example"].replace("{", "{{").replace("}", "}}")
        configfile.write(f"# Example: {option_name} = {option['example']}\n")

    if option["default"] is not None:
        if not isinstance(option["default"], str):
            raise Exception(
                f'Key "default" in element with name="{option_name}" has an invalid type. '
                f"Current type: {type(option['default'])}"
            )
        # Remove trailing whitespace on empty string
        if option["default"]:
            value = " " + option["default"]
        else:
            value = ""
        configfile.write(f"# {option_name} ={value}\n")
    else:
        configfile.write(f"# {option_name} =\n")


if __name__ == "__main__":
    airflow_config_dir = AIRFLOW_SOURCES_ROOT / "airflow" / "config_templates"
    airflow_default_config_path = airflow_config_dir / "default_airflow.cfg"
    airflow_config_yaml_file_path = airflow_config_dir / "config.yml"

    write_config(
        yaml_config_file_path=airflow_config_yaml_file_path,
        default_cfg_file_path=airflow_default_config_path,
        built_in_defaults_file_path=Path(airflow_config_dir) / "built_in_defaults.py",
    )

    providers_dir = os.path.join(
        os.path.dirname(__file__), os.pardir, os.pardir, os.pardir, "airflow", "providers"
    )
    for root, dir_names, file_names in os.walk(providers_dir):
        for file_name in file_names:
            if (
                root.endswith("config_templates")
                and file_name == "config.yml"
                and os.path.isfile(os.path.join(root, "default_config.cfg"))
            ):
                write_config(
                    yaml_config_file_path=Path(root) / "config.yml",
                    default_cfg_file_path=Path(root) / "default_config.cfg",
                    built_in_defaults_file_path=None,
                )
